# 讨论设备树解析的写法

`serde` 需要编译器确定，这对常常上下文相关的设备树解析是做不到的。通过留空来兼容，对于需要面对大量不同设备树定义的操作系统内核来说也不合适。设备树的 struct 段的设计决定了必须深度优先遍历，实现可选的只有是否递归。

现有的 crate 的，[device_tree](https://crates.io/crates/device_tree) 的问题是太老，“almost 6 years ago”。再修改这样古老的仓库是没有必要的。比较新的仓库，也没有特别注重性能的。

我希望实现一个满足下列要求的设备树解析：

1. 不要用堆

   设备树解析可能发生在各种阶段，可能在内核中，但也可能在早在内核的加载阶段甚至引导程序中。程序运行的介质也是多种多样的，可能在 SRAM 一类比较小的随机存储器。对于将作为环境持续运行的 hypervisor、SBI 或 kernel 来说，又需要通过解析设备树来确定真正适合放堆空间的地址空间在哪里。因此，如果解析设备树本身使用了堆，一定意味着较多的宝贵内存空间作为堆冗余被浪费掉了。

2. 性能极大化

   先遍历来建立完整索引，再通过索引访问的方式对于需要频繁随机访问的情况是合适的，因为只需遍历一次，后续的访问都能以渐进常数复杂度完成。但建立索引的方式是多样的，也有很多不需要建立索引甚至不需要完整遍历的情况。此时再使用至少遍历一次、还需要建立索引的封装就得不偿失了。

3. 作为标准的 Rust 映射

   目前设备树缺乏一种令人满意的实现，还有一个原因是[设备树标准](https://github.com/devicetree-org/devicetree-specification)本身缺乏一个通用的对定义和基本逐字节遍历的薄封装。因此，各种实现五花八门，无论是功能还是设计都无法统一。如果能实现一个足够薄又足够稳定的标准映射，成为其他实现的基础，对于定制化的设备树解析将大有帮助。

综上所述，我将从[翻译](20220528-translation-devicetree/toc.md)标准发布版本 [v0.4-rc1](https://github.com/devicetree-org/devicetree-specification/releases/tag/v0.4-rc1) 开始推进这个工作。
