# 对“切换”类指令的理解

开发者大概都熟悉这样的指令：

```asm
csrrw sp, sscratch, sp
```

这个操作在内核里称作“换栈”，将当前的栈保存在 `sscratch` 特殊寄存器里，并将 `sscratch` 中的值再存回栈指针，实际上就是将 `sp` 和 `sscratch` 交换了。`sp` 通常保存的是当前栈指针，如果 `sscratch` 里保存的是另一个控制流的栈指针，这个指令就实现了保存当前控制流切换到另一个控制流。

实际上 `csrrw` 指令不只能换栈，它啥都能换，并且有很多有用的 csr 都需要换，考虑以下操作：

| 功能 | 指令
| --- | -
| 切换地址空间 | `csrrw a0, satp, a0`
| 切换陷入地址 | `csrrw a0, stvec, a0`
| 切换内核状态 | `csrrw a0, sstatus, a0`
| 切换特殊跳转目标 | `csrrw a0, sepc, a0`

它们都是有意义的，尤其是需要实现高性能的控制流操作的时候。

如果补充一些序章谢幕，可能是这样（只是示意）：

```asm
ld    t0, 0*8(sp)
csrrw t0, satp, t0
sd    t0, 0*8(sp)

ld    t0, 1*8(sp)
csrrw t0, stvec, t0
sd    t0, 1*8(sp)

ld    t0, 2*8(sp)
csrrw t0, sstatus, t0
sd    t0, 2*8(sp)

ld    t0, 3*8(sp)
csrrw t0, sepc, t0
sd    t0, 3*8(sp)

csrrw sp, sscratch, sp
```

这就实现了个栈上的上下文和 csr 里保存的当前上下文交换。

---

> 注意到了吗，这里有些不同寻常的东西。交换 `stap`、`sstatus`、`sepc` 并没有什么特别的，但为什么会交换 `stvec`？通常我们假设内核只有一个陷入入口，但硬件上，这件事并不具有必然性。甚至读写 stvec 的操作在开销上也和读写任何特殊功能寄存器没有什么区别，那为什么要区别对待它呢？
>
> 实际上，不需要修改 `stvec` 的唯一原因就是内核相当简单，用同一套陷入响应总是能够处理。但如果内核既要调度内核线程，又要调度用户线程，可能还会调度协程，很可能就会面临需要不同陷入入口的情况。

---

另外，注意这个指令：

```asm
jalr ra, imm(t0)
```

这个指令具有奇妙的语义：`($t0 + imm) -> pc`、`pc + 4 -> ra`，本质上来说，这是在**交换** `pc`，只不过上面还附加了一些花里胡哨的偏移操作。

至此，可以说所有控制流切换都是由一系列“切换”指令形成的。这对将各种切换统一起来的努力大有裨益。
