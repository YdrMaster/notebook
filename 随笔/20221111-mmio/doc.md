# 存储映射和板级抽象

## 背景

目前，外设驱动有动态和静态两种模型。

![动态和静态驱动](./static-dynamic.png)

所谓动态驱动，实际上就是可以指定内存映射基址的驱动，通常实现为一个结构体，以及一系列基于结构体指针（`&self` 或 `&mut self`）的方法。相对的，静态驱动指的是所谓 HAL 库，即仅能在指定硬件上使用的驱动抽象层。这种库由于指定硬件，所有外设的基址就是编译前已知的，因此可以视作常量。HAL 通常的实现是一系列单元结构体，仅用于划分不同外设的功能，而不需要指定它们的基址。

目前，外设驱动的生态中二者并存。一方面，HAL 库在嵌入式系统中是惯例用法，嵌入式工程师习惯了随时静态地使用外设功能，不需要占用宝贵的内存空间存储一系列指针。另一方面，整个 HAL 生态在内核开发中是完全不可用的状态，因为内核通常运行在虚地址空间，无法通过静态锁定了物理地址的 HAL 库操作外设。

## 思路

我想，分析可以指定基址的外设映射和常量基址的外设映射，实际上后者是前者的特例和真子集。如果要统一就只能统一到可以指定基址的；然而存储大量指针又确实不是无开销的抽象。直到最近读了 [RISC-V ACLINT 规范](/translation/20221108-aclint.md)，我发现，什么东西算“一个外设”，似乎很有定义的空间。

RISC-V ACLINT，设计上是把 SiFive CLINT 拆散，允许每个部分独立指定基址。这样实现既更新定义，又向后兼容；一个传统的 SiFive CLINT Device，现在定义为留有合适空隙的 3 个 ACLINT Device 的组合。

那么，是不是可以把一个 `板`，定义成**基址为 0，长度为整个物理地址空间长度，由板上所有存储映射外设组合成的“一个外设”**?

## 板级存储映射

这个设计可以实现 HAL 模式和适用于内核的外设驱动的统一。

首先，由于一个 `板` 结构体在定义中保存了各个外设的相对位置，这些位置不需要用一系列独立的指针描述，所以对于直接使用的场景，只需要一个 `const BASE:usize = 0;`，是无开销抽象。

并且，这样的设计还类似于最近的 `rustsbi 0.3.0`，通过添加**最小并且可选的动态性**实现了虚拟化能力。比如通过定义一个基址不为零的 `板` 结构体，描述单页表内核的线性虚地址空间；以及在一个地址空间中虚拟出多个不同的 `板`。

而且，还可以通过在 `板` 结构体上定义方法，实现跨多个外设的功能封装。如此，时钟树、时钟门控的抽象，以及 GPIO 复用的抽象，甚至结合 DMA Controller 或 PLIC 的复杂外设功能，都有可能在板级优雅地封装起来。

另外，这样的 `板` 级映射结构体，也可以成为*通用配置文件*的生成目标。一个外设就是一个基址和基址上的寄存器映射、空隙占位符的组合。一个 `板` 就是一个基址和基址上外设映射和空隙占位符的组合。不同级别的封装都可以简单地统一起来了。实际上，**结构体**就是描述高级语言布局的一种方式而已。借助这种声明式的结构，编译器可以自动设置指针变量。所以，它不仅能描述一个外设或一个 `板`，也能描述任何静态的内存布局，比如整个内核虚地址空间或者类似的东西。

## 实现方式

这个模式下，外设库的作者不需要再考虑库是静态使用还是动态使用。只是一个定义而已，怎么用都是无开销的。那么，这样的库都会具有统一的形式：根据外设手册或其他定义性的描述定义的**寄存器**、**寄存器组**和**外设结构**的集合。

寄存器指的是这样的结构体：

```rust
#[repr(transparent)]
struct $Name(UnsafeCell($T));
```

- `$Name` 是寄存器的名字，通常是全大写的；
- `$T` 是匹配寄存器访问方式的整型：u8/u16/u32/u64；

寄存器组是寄存器结构的数组，同样 `#[repr(transparent)]`。

外设结构是寄存器、寄存器组和占位符组成的 `#[repr(C)]` 结构体，以及对这个外设操作的方法。

只要有手册，这样的 crate 应该可以批量生产。

## 非存储映射驱动

向静态的 HAL 模型添加动态性是困难的，HAL 模型和非 MMIO 外设——比如 PIO 型外设和 PCI 总线外设——绝对地无法统一。但仅仅生成结构体定义可以避开这个问题，因为结构体仅仅是在描述一个地址空间上的寄存器布局，而不假设使用它的地址空间一定是定义它的地址空间。为它生成的方法可以使用特殊的访问方式，如此，MMIO 外设和非 MMIO 外设的不同就能隐藏起来。

对于所有 MMIO 型驱动，它们的映射是 `板` 级映射结构体的一部分，因此不需要单独存储指针，是无开销抽象。而非 MMIO 驱动，只需要指定访问它地址空间的方式（比如通过特殊的指令或通过访问绑定的 `板` 级结构的某个总线控制器外设）。
