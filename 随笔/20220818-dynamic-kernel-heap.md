# 动态内核堆

> 关键词：设计，内存管理

## 目的

现在 _Core 的内核堆总是直接占用固定内存，既导致比较大的浪费（外碎片），有时候又会出现不够用的情况。其实内核堆完全可以动态起来，按需分配，和用户程序复用物理页帧（Linux 也是这么做的）。

## 设计

内核的内存管理涉及到内核的 4 方面功能：物理页帧分配、页表管理、内核堆分配和进程虚存管理。根据三者关系又有两种方式实现动态内核堆。

### 机制

物理页帧分配按需从全局可用的物理内存空间\*中找到可用的页帧提供给内核其他功能使用。由于管理的单位是页（通常 4 KiB）且不涉及权限控制，所以通常相对简单。比如使用 BitMap 方式，可以用一个位表示一个页，这样每个字节就能管理 32 KiB 物理内存，完全控制 256 GiB 空间才需要 8 MiB 额外空间，效率很高。

---

> - 物理页帧分配器下可以包括也可以不包括已经被固定占用的 MMIO 段、SBI 段和内核链接段，反正包括了就是永远不释放。设定问题不影响结果。

---

常见的实现方式就包括 BitMap 和伙伴分配器等，BitMap 的优点是简单，本身不需要额外内存；缺点是必须静态决定管理多大空间，如果实际管理的很小就会造成浪费。另外只适合单个 bit 分配小页，分配大页或多个连续页则比较麻烦。其他方案则根据设计可以快速分配多个页、大页、需要特定对齐的页，但实现比较难。最难的地方在于往往这些方案自身占用的空间也是动态的，如果要使用内核堆，内核堆就不可能反过来使用页帧分配器。最好能设计一些页上数据结构，让物理页帧分配器能自己给自己分配。

页表管理就是和硬件交互，将分配出去的物理页通过硬件页表映射到虚页。映射本身是很容易的，然而管理有困难。页表映射的数据页由于涉及权限管理，通常都要在什么地方记录，并且映射过程中还会产生数量不确定的中间页表（和物理页的连续性、对齐以及大页分配有关），这些显然都需要动态的空间存储，也就是需要内核堆。所以如果内核堆也需要页表映射出来就又产生了矛盾。换句话说，至少内核页表的管理也需要不依赖堆的页上数据结构。

接下来是内核堆。动态的内核堆应该管理着内核虚地址空间的内核动态区，这上面的虚页初始都是没映射的，每次从一个新的页对齐区上分配时就映射一个，每次一个整页释放时就解除映射。堆管理的单位是字节，这样再使用静态的 BitMap 实现就很低效了，而其他方案又需要动态分配。并且这些分配回收过程还都需要和页表联动。

最后是进程虚存管理。这个还算相对容易一些，因为内核的其他部分不会依赖它。只需要先把页帧分配器和堆分配器弄好就行了。

### 方案

以上其实已经介绍了复杂的方案：必须先设计一些自给自足的、能够高效利用整个物理页帧的数据结构。物理页帧分配器、页表管理器和内核堆分配器都要基于这样的数据结构保存自己，然后作为一个整体向进程虚存管理器提供功能。

实际上，“作为一个整体”这件事提醒了我们，还有另一种方案，就是直接实现一个静态的堆分配器，然后由堆分配器模拟出页帧分配器的行为，共同支持页表管理器，最后再服务于进程虚存管理器。换句话说，将本来应该由物理页帧管理器管理的整个可用物理页区域交给一个以字节为单位的分配器使用，将物理页帧分配描述为分配对齐到 4 KiB 的 4 KiB 字节数组。这样可能效率较低，但确实是一种可行的简化设计，并且依然支持内核堆与进程共享物理内存。
