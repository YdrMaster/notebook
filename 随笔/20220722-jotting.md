# 随笔：Rust 的目的

如果说要从以下三个选项中选出一个最接近 Rust 语法的设计目的：

1. 方便包的管理和分发；
2. 无开销抽象；
3. 内存安全和无惧并发；

你会怎么选择？

Rust 官方的宣传总是 3，推荐 Rust 的理由通常是 1，但我会选择 2。
因为 3 太细节，太片面了，不足以全面地描述 Rust 的特性选择。但是如果加上 Rust 其他的那些宣传语，则又太繁琐，无法成为一个目的。所有具体的特性，都注定了只是实现目的的手段而不足以成为目的。
但是 1 又太宏观，或者不如说是宏大了。生态的繁盛需要很多客观的助力，宣传、背书，这不是 Rust 这样一个个人开始于个人的项目可能选择的目标。即使是作为 Mozilla 的官方项目，也还是太宏大，Mozilla 没这个能力。更不要说也许生态更多依赖的是天时地利、机缘巧合，根本无法基于这个目标做出合适的技术设计。更大的公司（比如这次（Carbon）和上次（Kotlin）的 Google）也许有资格选择这样一个目标，但这种目标得到的成果一定充斥着商业化的妥协，而不会像 Rust 这样，带有一种工程师特有的气质，时而坚决狂热，时而漫不经心。

但是无开销抽象就很适合成为一种“目的”，而且也能够指导目前的选择。编译执行、直白的结构体、泛型静态分发、使用引用计数拒绝垃圾收集，显然都能为无开销抽象服务。甚至基于所有权和生命周期的内存安全（或者说竞态和悬垂避免）、基于类型标记的无惧并发，也可以解释为为了无开销服务，因为有了这些静态保证，自然可以减少动态检查，以及各种防御性的设计。
而包管理和分发的方便则可以视为无开销抽象的结果。因为语法特性不止保证了一个项目内部的无开销，也同时保证了源码引用的情况下依赖访问无开销。而广泛使用依赖库的先决条件之一就是使用依赖不会带来不可接受的性能损失（换句话说，自己写也无法获得更好的性能——这是无开销抽象的定义）（再换句话说，如果你总能接受任何性能损失，使用依赖就很简单，比如 Python）。

那么 Kotlin 的目的是什么呢？我只能说，是为了发泄对 Java 的不满。看看 Jetbrain 急不可耐地在 idea 里用缩写机制把 Java 硬缩成 Kotlin，23333，我都看出 Kotlin 恐怖谷了（很像 Kotlin，但又有一点不像）。

那么 Carbon 的目的又是什么呢？如果说是为了发泄对 C++ 的不满的话，我觉得可以理解，但是很可能会被 C++ 同化掉而失去自我，毕竟 C++ 程序员都很儒雅随和的，他们甚至能接受 CMake，再多一种构建器语言也没什么大不了的，如果这个构建器还附赠跨平台包管理的话就更好了。也没准 Google 的设计就是如此呢。

---

看到 Carbon 宣发有感

2022-07-22
