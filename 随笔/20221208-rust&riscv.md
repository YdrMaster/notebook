# 下一代嵌入式基础软硬件（Rust/RISC-V 在嵌入式系统中的应用）

## Rust：适用于嵌入式的当代语言

嵌入式设备在成本、功耗、实时性和可靠性方面具有优势，代价是有限的存储和计算资源。

我将在本节介绍，为什么 Rust 语言这种当代语言适用于资源有限的嵌入式系统，如果要在嵌入式系统中使用 Rust，能获得何种独特的优势，以及 Rust 还有什么缺点。

如果要下个定义的话，Rust 是一种遵循零开销原则的当代语言。换句话说，它既有当代编程语言的特性和生态，同时满足零开销原则，也就是下面这两条：

1. 不必为不使用的东西付出代价
2. 使用的抽象和合理的手写代码性能一致

为了做到这一点，Rust 支持很多兼容于 C 语言的特性：

1. 首先，Rust 不需要运行时，也可以移除运行时库。所以 Rust 编写的程序可以在裸机运行，这是 Rust 能用于嵌入式的必要条件。
2. 其次，Rust 还支持 C++ 规范描述的 POD 结构体，这样 Rust 的结构体就能在 C 或者汇编里操作，也可以用 Rust 的结构体定义寄存器映射。
3. 另外， Rust 里有胖指针的概念，而不像 C++ 那样使用隐式虚表，所以 Rust 在面向对象编程时也能保持精细的控制。
4. Rust 还支持暂时放弃编译器的约束，也就是所谓的 unsafe Rust，这种情况下可以直接使用裸指针，也就能获得和 C 完全一样的自由度。

同时，在维持零开销原则的基础之上，Rust 支持许多当代语言的特性。比较著名的一项是内存安全性。很多现代语言都是内存安全的，比如 Java、C#、Python，但是这三种语言都是依靠运行时托管的垃圾收集才能实现内存安全的，运行时带来的开销很大，而且一旦使用，就永远失去了开发实时系统的能力。Rust 利用独特的所有权/生命周期，以及一系列特性，不需要运行时也能实现不比 Java 这样的语言差太多的内存安全性，这是比较神奇的。

另外，C++ 发明至今已经 40 年了，这 40 年里，C 语言并没有发生多大变化，但另外几十种高级语言上已经发展出很多新的语言特性。Rust 可能是第一种能把这些特性带到嵌入式世界的语言。包括这里列出的模式匹配、闭包、泛型、RAII——也就是资源申请即初始化，这是 C++ 的概念，本质是自定义析构函数实现的资源自动申请和释放。还有 trait，可以翻译成特质，这是一种面向对象的抽象方式。

这些特性大部分都不是 Rust 原创的，而是经过其他很多广泛使用的语言验证过的，Rust 只是把它们无开销的实现出来而已。所以这些特性的效果都是有保障的。只要合理使用这些特性，就一定可以给开发带来方便，尤其用这些特性能做出充分封装的库，这会大大提升项目代码的工程性。

基于这样的特性，Rust 就有可能补上 C 和 C++ 最致命的短板，也就是构建工具和包管理问题。众所周知，使用 C/C++ 开发的时候最麻烦的就是编译，各个平台都要使用不同的编译器，在自己的环境里编译一个库就已经很困难了，还要移植不同平台开发的库到自己的平台上，还要统一构建工具，非常麻烦。而且各个库的更新和版本管理都需要一一处理。

而 Rust 从一开始就重点关注了这个问题，官方，也就是 Rust 基金会，直接建立了第一方的工具链和包管理平台。包的管理和分发都非常容易。由于 Rust 的零开销原则，Rust 即使使用很多小库也不会损失性能，所以 Rust 的包管理平台很活跃，通过分发和依赖库，可以极大降低重复造轮子的问题。

最后就是 Rust 语言本身的发展。Rust 为了避免语言和工具链更新带来的问题，从一开始就建立了一个稳定的核心团队，包括语法工作组、编译器工作组、构建工具工作组、文档工作组等小组，这样的组织结构下，Rust 实现了定期更新，具体来说，3 年一个大版本，目前已经发布了 2015、2018、2021 三个大版本。工具链是 6 周一个稳定版本，每天一个最新版本，按这个稳定的节奏已经运行了很久了。这种定期更新的模式经过 C++、Java、C# 这三个最工程的语言验证，被证明是目前最好的支持模式。

Rust 还有一个活跃的社区。许多 Rust 语言的用户直接在 Github 上讨论 Rust 语言的语法和特性，所谓集思广益，这种开放的氛围保证了 Rust 的发展不会像很多个人或者小团体维护的语言那样走偏。

当然，还需要说清楚使用 Rust 的劣势。目前使用 Rust 或者除 C/C++ 以外的任何语言的嵌入式开发都面临相同的问题：缺乏厂家的直接支持，尤其是工具链支持。

很多硬件有特殊的扩展功能，厂家往往会扩展来支持这些功能，但扩展的工具链必须使用 C 语言开发才能使用，最多加上 C++，其他语言不会提供。常见的特殊功能除了图形化的配置之外，一般会有 `__attribute__` 属性修饰，这个一般是提供一些运行时功能，比如指定某个静态变量或函数放在地址空间的某个区域，或者指定某个函数是中断响应函数或者嵌套的、向量的中断响应函数。另外就是硬件规范会描述的扩展寄存器和指令集。比如我知道的阿里平头哥的玄铁扩展、南京沁恒微电子的青稞扩展。这俩都是扩展了寄存器和指令来实现一些操作加速。

这个问题是可以解决的，但是需要知道这些特殊工具链的扩展功能是怎么生效的。比如 `__attribute__` 一般是在对象前后添加修饰的，比如说让函数入口具有特殊的对齐或者在函数前后增加一些固定的代码。这种功能可以用 Rust 的过程宏模拟出来。扩展的寄存器和指令需要特殊的汇编器，由于 Rust 的编译器后端是 LLVM，只要使用 LLVM 支持的汇编扩展就行了。`.insn` 伪指令可以像高级语言内联汇编那样在汇编里内联机器码，所以只要知道扩展指令的机器码，就能手工使用扩展指令。实际上，我们就按这个方案维护了平头哥的玄铁指令集扩展库。

以上就是我对 Rust 语言与嵌入式软件关系的分析。

## RISC-V：开源的模块化指令集架构

第二部分，我想介绍的是 RISC-V 这个开源指令集架构，包括它基础+扩展的设计，以及它的开源特性带来的繁荣生态、以及它是如何靠标准体系来对抗开源带来的碎片化倾向的。

RISC-V 这个名字是第五代精简指令集的意思，根据手册描述，V 还表示*变体 Variation* 和*向量 Vector*。精简指令集意味着这个指令集尽量减少指令的种类和数量，除非有特别的理由，否则不为多个指令的组合实现一个新的、复杂的指令。最终的效果是 RISC-V 架构下只有 6 种基本指令格式和 1 种压缩指令格式。所有基本格式都是 32 位，压缩格式 16 位。另外，所有访存指令都只涉及一个地址和一个寄存器，所以 RISC-V 没有 x86 那样复杂多样的寻址方式。这节省了大量的指令数。

但 RISC-V 最大的特点在于它是模块化的。目前市场上只有这一种指令集架构具有这样的特点。

它的核心是一个名为 RV32I 的基础指令集。RV32I 是任何 RISC-V 指令级的共同子集，它一旦在规范中锁定就永远不会改变。这就为 RISC-V 的软件开发提供了一种稳定性。对于只涉及这个部分的软件来说，无论在什么硬件上都可以运行。对于更复杂的硬件，RISC-V 的所有扩展都通过一个个的扩展模块来支持，由于添加新模块是比较容易的，所以每个模块就可以做得相对简单，并且稳定。这实际上和 Rust 通过无开销且易于分发的库减少重复造轮子是一样的。

硬件模块化之后，软件只需要确认自己需要哪些扩展，就可以确认自己能在哪些硬件上运行，这个特性使得 RISC-V 的软件也可以伴随硬件模块化，而且是比较稳定的。而且硬件厂商很容易根据支持的模块数量来划分产品线，用户选型也更容易，可以少为自己不需要的功能付费。

从本身的组织结构来说，RISC-V 是由基金会推动的。基金会会负责维护一系列开源的规范文本仓库，并定期发布各种规范文本。通过规范文本，RISC-V 实现了设计与实现的分离。软件可以完全基于规范文本开发，就能跑在所有兼容硬件上，而规范文本本身是开源的，允许任何开发者参与讨论。这样就实现了先在规范文本整合各方意见，再实现对应的硬件，避免了直接实现硬件可能出现的碎片化问题。

这些特点本身就是特别有利于国内硬件厂商的。以前的架构，x86 一直就拿不到新版的授权，ARM 也会卡脖子，但 RISC-V 没这种问题，所以在国内发展特别好。可以说 RISC-V 基本上是这一代国产硬件的唯一选择。
