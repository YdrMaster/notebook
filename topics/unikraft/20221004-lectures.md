# 幺内核与模块组合式操作系统

## 写在前面：实验性

首先，我想说明的是，我们近期的一些活动，都带有一定的实验性质。比如大家之前参加的我们的开源操作系统夏令营，今年是我们第一次完全在线上开展。所以虽然二阶段每个项目每周能开一两次会吧，但交流的密切程度毕竟不如以前线下。

另外，二阶段的课题，实际上只有陈志扬的调试器是一个正在做的项目，其他都是一些想法而已，虽然有些有前人工作的成果，但一般也不是很好上手，可能还有各种版本问题，仅仅是复现，一个月的时间就过去了。所以这次我希望模仿陈志扬那个项目，把我们正在思考的一些新想法拿出来跟大家分享和讨论，这样对我们来说，对想法的理解会更充分。另外让更多的人参与同一个项目，也会有更好的讨论氛围。

我们这次的课程+项目包括 6 次课程——也就是我给大家讲我们已经知道什么——以及 2 个可选的课题——也就是让大家写出自己对这个想法的理解。我说的想法，意思是不同于操作系统课或者夏令营一阶段那样基于经典的操作系统教材和 rCore-Tutorial，相对来说，我们这些新想法都是很不成熟的。我只能说尽量把逻辑讲通顺，但是这个并没有经过很多人的验证——或者说正在等待线上的各位来验证——很可能有我不了解或者说的不对的地方，希望大家有啥问题就直接提出来，让我们这个实验能开展好。

> 那接下来我先来介绍这个想法大概是什么。

## 引言 定制性与模块化

用一句话描述：我们的目标是找到一种构造定制化操作系统的方式。

在不同的领域，操作系统仍然百家争鸣。从大量简单的嵌入式操作系统，到桌面级的 Windows，再到跨领域的 Linux，各有特色。但即使是最通用的 Linux 也不是万能的。比如 Linux 就不适于在没有 MMU 的单片机上运行，虽然也有人做了这个级别的裁剪，但可用性并不好。按照传统的定义，操作系统要运行在具体硬件上，服务于应用程序。不可能做出适用于任何领域的操作系统，必须适应运行的硬件的和服务的应用程序。要充分发挥硬件的能力、尽量好的服务应用程序，或者尽量符合某个特定应用场景的需要，都需要定制的开发。

### 定制的方法

定制开发本身并不罕见。对于操作系统、或者 uboot、sbi 这样的裸机程序，经常是对每个硬件都使用一份不同的代码。对于那种有一个“官方”在持续维护的仓库，比如 uboot、opensbi，会有一个将平台支持“并入主线”的操作，实际上就是把为了那个平台而修改的代码用编译选项包起来。C/C++ 用 `#if` 在预编译步骤实现这种功能，Rust 则使用 feature。用编译选项就能尽可能的复用代码同时兼顾定制性。

但针对硬件定制开发操作系统的成本相对于开发硬件本身来说是比较小的，所以还算是有一定的可行性，针对应用定制开发就过于昂贵了。目前业界的解决方式总结起来是在人力贵的场景堆算力，在算力人力贵的场景堆人力（换句话说，就是把成分分摊到开发的各个环节）。比如说玩游戏的时候，要获得好的游戏体验，实际上是在硬件、驱动、游戏三层各自进行定制才做到的。一些专业软件，也可能会需要在特定的甚至专门修改过的软硬件上才能达到最好的效果。大部分软件实际上都是为了通用性放弃了最佳的性能表现。

出于成本考虑，目前操作系统和应用程序一般来说是尽量互相适配，除非是对操作系统特定机制的研究，很少有针对应用程序定制操作系统的情况。这实际上导致在某些情况下，操作系统会成为性能瓶颈。但即使已经确认操作系统就是性能瓶颈，可能的方案也主要是躲开操作系统的特定部分，称为操作系统旁路，我指的是 DPDK。很多操作系统研究者都注意到这个问题，学术界也有一些针对这个的问题的探索。

### 复杂性的来源

定制操作系统的困难性，实际上源自操作系统的复杂性。那么，操作系统的复杂性来自哪里呢？《面向对象分析与设计》这本书中提出**复杂性是软件的基本特征**，来源有 4 个：

- 问题域本身的复杂性：软件是为了解决现实生活中的问题，而现实生活中存在着大量的需求。并且需求是会不断发生变化的，这种外部的复杂性导致了软件的复杂性；
- 管理开发过程的困难性：开发功能复杂的系统必须团队协作，但团队协作会带来更多的沟通，协调，这方面的困难也增加了软件的复杂度；
- 软件中随处可见的灵活性；
- 描述离散系统行为的问题；

按照我的理解，这 4 个来源在操作系统的开发中可以具体化成：

- 操作系统运行的硬件、服务的软件本身的多样性；
- 协作开发带来的复杂性；
- 具体某个子问题没有最优解；
- 为了处理大量 corner case，必须枚举出各种情况；

显然，如果问题不变，解决方案的复杂性就不会无缘无故地消失。只有通过把复杂问题分解成简单的问题，才能驾驭复杂性。这就引出了我们的主题之一，通过将操作系统分解成许多模块，来消解上述的 4 个复杂性来源。比如，针对硬件多样性的问题，可以将硬件的特殊性隔离在模块里，编译时选择一个平台模块。只要模块有明确的应用范围和导出接口，协作开发的问题就会自然消解。子问题没有最优解，但是提供多个接口相同的模块，针对某一个应用程序选择一个加入操作系统。corner case 的问题虽然不会直接被模块化解决，但每个模块里的情况肯定减少了，所以整体的复杂性还是能降低。

## 幺内核

显然，模块化开发会有一个从简单到复杂的过程，需要先确定一个最简单的操作系统至少要有哪些模块。Linux 也可以运行时插入内核模块，主要是各种驱动，还有协议栈扩展之类的，但是 Linux 内核本身还是过于复杂，我们希望把内核也拆分成模块，这就要介绍 unikernel，我自己翻译成幺内核。

幺内核是一种很新的概念，当然，所谓新，这个概念其实也提出了十几年了，只不过由于基本停留在学术界，业界没有应用，所以这个概念听起来很陌生。

要阐述幺内核的概念，首先需要解释这个名字：unikernel。我们可以把这个词和宏内核、微内核这两个词放在一起看：

| monolithic kernel | microkernel | unikernel
| ----------------- | ----------- | -

宏内核的 monolithic 翻译成中文有两种侧重：宏大的、单一的，而微内核和幺内核可以视作对两种意思的发展。所谓宏大的指的是整个内核的各个部分是一大坨，所有的驱动、以及分配、调度的各种机制都是内核的一部分，那自然也是单一的了。微内核的宗旨就是减少内核的功能，凡是可以放在内核外部的东西就从内核里拿出来，而且最好能放在和内核不同的特权级、不同的地址空间，这样一方面精简内核实现，减少发生 bug 和漏洞的可能性，另一方面利用硬件机制隔离那些被裁剪出去的部分可能发生的问题，让那些部分即使崩溃也能不影响内核本体。

unikernel 的 uni- 这个前缀，也是表示单一的意思，例如 unique。这个单一描述的不是内核实现，而是内核服务的应用程序，也就是说 unikernel 是只能运行一个应用程序的操作系统。换句话说，unikernel 实际上是对内核功能的另一种精简方式，退化功能的精简方式。

> 从某种意义上说，微内核和幺内核是相反的，微内核把内核功能变成进程。极端情况下，微内核可以只有进程间通信的系统调用。而幺内核直接砍掉了运行多个应用程序的能力，也就不需要进程间通信相关系统调用了。

回想 rCore-Tutorial，从一上来能加载应用程序，就是一下加载一堆应用程序，因为最开始发明操作系统就是为了能连续运行应用程序，减少等待时间，提高计算机硬件的利用率。随着管理的资源越来越多，内存和外设也可以由多个应用程序共享，提高利用率。那为什么现在又反过来提出要搞只运行一个应用程序的操作系统呢？

这是因为时代变了，在发展过程中，往操作系统里塞的功能越来越多，尤其是系统调用这个概念，把应用程序和硬件完全隔离开了。于是操作系统的重心逐渐变了，不再是怎么更好的共享，而是怎么多样化的服务应用程序。最典型的就是抢占调度，按理说尽量减少上下文切换开销，让一个程序尽可能连续跑更有利于提高计算资源利用率，但是由于对事件响应速度的需求不得不增加了抢占调度。另一方面，硬件的能力也越来越强，在某些场景下甚至会强到超过一个操作系统容纳的范围。于是出现了各种虚拟化技术，在一台云服务器上同时运行多个不同的操作系统，为多个用户提供接口不同、高度隔离的使用体验。随着时代进一步发展，人们发现用云服务器非常的不方便：性能上限太低，下限太高。上限太低使得服务器无法很好地处理爆发式的大规模请求；下限太高使得闲置的服务器也需要收取不菲的费用。这时候出现了 serverless 的概念，用户提供自己希望运行的函数，在它每次需要执行的时候，开启一个容器内核，执行完成后就将容器内核删除。这样没有请求时就不会被收取费用，而有爆发请求时也可以很好地处理。实际上是在云上，共享的范围更大了，于是操作系统的共享功能被提到了操作系统之外。

在这种场景下，一个完整的内核，很可能大部分功能都用不到了，但是内核本身却不能去掉，因为现代应用程序开发都是基于操作系统的，所有高级语言的标准库都依赖后来塞进操作系统里的各种分配、调度和硬件访问功能才能工作，就算能砍掉一部分，也不可能回到裸机开发的远古时代了。所以我们需要 unikernel，只运行一个应用程序的操作系统。

一个幺内核包含一个应用程序以及支持这一个应用程序所需要的自上而下的所有环境，比如标准库、协议栈、设备驱动等等。其他的部分就可以裁剪掉了，比如一个基于 UDP 的服务器就不需要一套 Linux 中完整的网络协议栈。

更重要的是，如果只有一个进程，就意味着只有一个地址空间，那么地址空间切换的开销就不存在了。进一步考虑，实际上特权级隔离也不再必要了，因为特权级本来就是为了进程崩溃或被杀时内核依然保持运行，单如果内核本来就只运行一个应用程序，随着应用程序结束而退出，那自然特权级也没必要了。如果特权级、虚地址都不存在的话，系统调用实际上也会退化成函数调用。于是我们发现对于幺内核来说，连特权级、虚地址、系统调用这样的真·核心机制也是能裁剪掉的。于是操作系统就变成了一个特殊的“库”，链接这个库就会使应用程序能够运行在裸机上。

回到模块化的主题，幺内核的现有研究显示，内核模块化的上限实际上非常高，对于宏内核甚至微内核来说核心的东西也可以变成可选的模块。这样，随着时代发展逐渐复杂化模糊化的操作系统，现在也可以重新定义了：在一个硬件上运行的所有软件中，先定义出一个应用程序，则为应用程序提供支持的其余部分就是操作系统。同时，这样高度精简高度定制化的内核，也自然会更小、更快、更安全。

> 安全在不同语境有不同含义：rust 的内存安全指的是不容易写出 bug，幺内核的安全指的是不容易被攻击，因为“攻击面”，或者说能攻击的组件变少了。

## 幺内核的定制性需求

讲完了幺内核的概念，我们会发现，幺内核存在一种必然的定制要求。因为就是在能针对应用程序，裁剪掉一部分内核的情况下幺内核才有优势，所以幺内核必须定制开发。那么定制开发的成本怎么支付呢？实际上这也正是幺内核的概念提出并不晚，理论也很直观，但是目前应用仍然很少的原因。结合我们之前讲到的内核复杂性来源和解决方案，能得到一个很顺理成章的结论：有实用价值的幺内核要么只用于特定领域，否则就必须是模块组合式的。在这个思想下，就自然引出了我们课程前半部分要介绍的内容，unikraft 这篇论文。

> 本节之后的内容为论文原文的摘录和翻译：

论文描述：

- Unikraft 是一个新颖的微库操作系统：
  1. 完全模块化的操作系统基元，因此很容易定制幺内核并只包括相关的组件；
  2. 暴露了一套可组合的、面向性能的 API，以便使开发者容易获得高性能；
- 用现有的应用程序（如 nginx、SQLite 和 Redis）进行的评估表明：
  - 与 Linux 虚拟机相比，性能提高了 1.7-2.7 倍；
  - 应用的镜像约为 1MB，运行时需要不到 10MB 的内存；
  - 在虚拟机启动时间之外，启动时间约为 1ms（总启动时间为 3-40 ms）；

Unikraft 的设计目标是：

- 单一地址空间：以单一应用场景为目标，可能有不同的应用通过网络通信交流。
- 完全模块化的系统：所有组件，包括操作系统基元、驱动程序、平台代码和库，都应该易于根据需要添加和删除；甚至 API 也应该是模块化的。
- 单一的特权级：不应该有用户/内核空间的分离，以避免昂贵的处理器模式切换。这并不排斥区隔化（例如微库），这可以以合理的开销实现。
- 静态链接：启用编译器功能，例如死代码消除（DCE）和链接时优化（LTO），以自动摆脱不需要的代码。
- 支持 POSIX：为了支持现有的或遗留的应用程序和编程语言，同时仍允许在该 API 下实现专用化。
- 平台抽象化：为一系列不同的 Hypervisor/VMM 无缝生成镜像。

为了实现模块化的总体原则，Unikraft 由两个主要部分组成：

- 微库。微库是实现 Unikraft 核心 API 之一的软件组件；我们将它们与库区分开来，因为它们具有最小的依赖性，可以是任意小的，例如一个调度器。所有实现相同 API 的微库都是可以互换的。一个这样的 API 包含多个内存分配器，它们都实现了 `ukalloc` 接口。此外，Unikraft 支持的库可以提供来自外部库项目（OpenSSL、musl、Protobuf 等）、应用程序（SQLite、Redis 等）、甚至平台（如 Solo5、Firecracker、Raspberry Pi 3）的功能。
- 构建系统。它提供了一个基于 Kconfig 的菜单，让用户选择在应用程序构建中使用哪些微库，让他们选择目标平台和 CPU 架构，甚至在需要时配置单个微库。然后，构建系统对所有的微库进行编译，将它们链接起来，并为每个选定的平台生成一个二进制文件。

这是 unikraft 内核总体的结构图：，注意，由于 unikraft 会把应用程序和内核链接成同一个二进制文件，所以这个图顶层直接就是 application。大概的结构是应用程序依赖 libc——但这个 libc 其实是一种改过的 libc，因为系统调用需要变成函数调用。论文里提到 x86 可以不改，因为 x86 上在特权态调用 syscall 指令会留在特权态。但是 riscv 上在 s 态 ecall 会发送到 m 态 sbi 那里去，所以 riscv 上 libc 是必须改的。libc 之下是 posix 兼容层、操作系统机制层和平台层。黑底的意味着一个接口模块，可以选用底下框出来的多种实现模块中的一个。

这是 helloworld 和 nginx 两个应用程序在 unikraft 上的依赖关系图，可以看到 nginx 还稍微复杂一些，但也不难懂。helloworld 可以说就是高度精简了，只有 4 个模块，一个提供 posix 兼容的 nolibc——所谓 nolibc 就是只有纯库代码的一个 libc，所有系统调用都直接是一个函数声明。剩下那些实现模块会实现和 libc 系统调用函数名一样的一些函数，链接的时候会把声明和实现静态链接起来——boot 是裸机启动必要的汇编以及分配器初始化什么的，argparse 是解析参数的，其实这个都可以去掉，还有一个 memory management，里面是一个 ukalloc 接口库和一个伙伴分配器实现。

这是 unikraft 的代码和构建出来的镜像的大致情况。另外它还有一个构建系统。实际上 unikraft 的代码也并没有特别特殊的地方，就是正常的 C 语言项目。真正使得它能够快速构建出针对性的内核，是靠的它这套构建系统。C 语言并没有自己的标准构建系统嘛，所以 unikraft 是用一些基于文本的配置文件和 Makefile 写了一个出来。靠这个构建系统，以及配套的两个命令行工具，一个是 Linux KConfig 用的 menuconfig，可以在终端里可视化配置的一个东西，另外一个是他们自己做的一个命令行工具，叫做 kraft，支持一些命令，会自动读配置文件、甚至去 git 上拉代码什么的，最后把镜像建出来。

我们用 helloworld 演示一下：

1. kraft list 关联仓库列表
2. kraft list pull unikraft 拉内核仓库
3. kraft list pull helloworld 拉 helloworld 应用程序仓库
4. tree -L 2 看 .unikraft 结构
5. cd apps/helloworld 进应用程序目录
6. kraft menuconfig
7. kraft build
8. qemu-system-x86_64 -nographic -kernel
