# “Smclic”核内中断控制器（CLIC）RISC-V 特权架构扩展

> "Smclic" Core-Local Interrupt Controller (CLIC) RISC-V Privileged Architecture Extension

> [原文](https://github.com/riscv/riscv-fast-interrupt/blob/a4dc0e2/clic.adoc)（未发布，这是翻译时的最新版本）

## 目录

> Table of Contents

1. [修订历史](#1-修订历史)
2. [背景和动机](#2-背景和动机)
   1. [原始的 RISC-V 基本本地中断（CLINT 模式）](#21-原始的-risc-v-基本本地中断clint-模式)
   2. [对比 CLIC 模式和 CLINT 模式](#22-对比-clic-模式和-clint-模式)
   3. [对比 CLIC 和 PLIC](#23-对比-clic-和-plic)
   4. [对比 CLIC 和高级中断架构（AIA）](#24-对比-clic-和高级中断架构aia)
3. [CLIC 概述](#3-clic-概述)
   1. [中断抢占](#31-中断抢占)
   2. [CLIC 和其他本地中断的交互](#32-clic-和其他本地中断的交互)
4. [CLIC 的内存映射寄存器](#4-clic-的内存映射寄存器)
   1. [CLIC 内存映射](#41-clic-内存映射)
   2. [CLIC 配置（`cliccfg`）](#42-clic-配置cliccfg)
   3. [CLIC 中断挂起（`clicintip`）](#43-clic-中断挂起clicintip)
   4. [CLIC 中断使能（`clicintie`）](#44-clic-中断使能clicintie)
   5. [CLIC 中断属性（`clicintattr`）](#45-clic-中断属性clicintattr)
   6. [CLIC 中断输入控制（`clicintctl`）](#46-clic-中断输入控制clicintctl)
   7. [CLIC 中断触发器（`clicinttrig`）](#47-clic-中断触发器clicinttrig)
5. [CLIC 控制和状态寄存器](#5-clic-控制和状态寄存器)
   1. [`xstatus` CSR 的变化](#51-xstatus-csr-的变化)
   2. [代理（`xedeleg`\/`xideleg`）寄存器的变化](#52-代理xedelegxidelegcsr-的变化)
   3. [`xie`\/`xip` CSR 的变化](#53-xiexip-csr-的变化)
   4. [用于 CLIC 的 `xtvec` CSR 新模式](#54-用于-clic-的-xtvec-csr-新模式)
   5. [新增的 `xtvt` CSR](#55-新增的-xtvt-csr)
   6. [`xepc` CSR 的变化](#56-xepc-csr-的变化)
   7. [{dpc} CSR 的变化](#57-dpc-csr-的变化)
   8. [`xcause` CSR 的变化](#58-xcause-csr-的变化)
   9. [下一个中断处理地址和中断使能寄存器（`xnxti`）]
   10. [新增的中断状态（`xintstatus`）寄存器]
   11. [新增的中断级别阈值（`xintthresh`）寄存器]
6. [CLIC 参数]
   1. [MCLICBASE]
   2. [NVBITS 参数 - 指定对选择性硬件中断向量的支持]
   3. [CLICINFO 参数]
   4. [其他 CLIC 参数]
7. [CLIC 复位行为]
   1. [CLIC 强制复位状态]
8. [CLIC 中断操作]
   1. [一般中断概述]
   2. [中断处理程序中的关键部分]
   3. [在等待中断（WFI）指令后导致硬件线程恢复执行的 CLIC 事件]
   4. [同步异常处理]
   5. [从处理程序返回]
9. [中断处理软件]
   1. [中断栈软件约定]
   2. [C 语言的内联中断处理程序和“中断属性”]
10. [调用 C-ABI 函数作为中断处理程序]
    1. [C-ABI 跳板代码]
    2. [为嵌入式 RISC-V 修订的 C-ABI]
    3. [C-ABI 跳板在最坏情况下的中断延迟的分析]
11. [中断驱动的 C-ABI 模型]
12. [用于软件向量的备用中断模型]
    1. [单权限态下内联中断处理程序的 `gp` 跳板]
    2. [可抢占的内联处理程序的跳板]
13. [管理跨权限态的中断栈]
    1. [交换软件特权栈]
    2. [多权限态下可选的突发交换寄存器（`xscratchcsw`）]
14. [为每个中断级别分别设置栈]
    1. [不同中断级别可选的突发交换寄存器（`xscratchcswl`）]
15. [CLIC 中断 ID 排序建议]
    1. [保持中断 ID 兼容于 CLINT 模式的系统时，CLIC 模式的中断映射]
    2. [适用于带有 PLIC/APLIC 的单线程系统的 CLIC 模式中断映射建议]
    3. [适用于无 N 扩展、无 PLIC/APLIC 的 M/S/U 态单线程系统的 CLIC 模式中断映射建议]
    4. [适用于仅 M 态或 M/U 态的单线程系统的 CLIC 模式中断映射建议]

    附录A：附录

    - A.1. 原型 DTS 条目

16. 书目

索引

> 1. Revision History
> 2. Background and Motivation
>    1. Original RISC-V basic local Interrupts (CLINT mode)
>    2. CLIC mode compared to CLINT mode
>    3. CLIC compared to PLIC
>    4. CLIC compared to Advanced Interrupt Architecture
> 3. CLIC Overview
>    1. Interrupt Preemption
>    2. CLIC Interaction with Other Local Interrupts
> 4. CLIC Memory-Mapped Registers
>    1. CLIC Memory Map
>    2. CLIC Configuration (cliccfg)
>    3. CLIC Interrupt Pending (clicintip)
>    4. CLIC Interrupt Enable (clicintie)
>    5. CLIC Interrupt Attribute (clicintattr)
>    6. CLIC Interrupt Input Control (clicintctl)
>    7. CLIC Interrupt Trigger (clicinttrig)
> 5. CLIC CSRs
>    1. Changes to xstatus CSRs
>    2. Changes to Delegation (xedeleg/xideleg) CSRs
>    3. Changes to xie/xip CSRs
>    4. New xtvec CSR Mode for CLIC
>    5. New xtvt CSRs
>    6. Changes to xepc CSRs
>    7. Changes to {dpc} CSRs
>    8. Changes to xcause CSRs
>    9. Next Interrupt Handler Address and Interrupt-Enable CSRs (xnxti)
>    10. New Interrupt Status (xintstatus) CSRs
>    11. New Interrupt-Level Threshold (xintthresh) CSRs
> 6. CLIC Parameters
>    1. MCLICBASE
>    2. NVBITS Parameter - Specifying Support for Selective Interrupt Hardware Vectoring
>    3. CLICINFO Parameters
>    4. Additional CLIC Parameters
> 7. CLIC Reset Behavior
>    1. CLIC mandatory reset state
> 8. CLIC Interrupt Operation
>    1. General Interrupt Overview
>    2. Critical Sections in Interrupt Handlers
>    3. CLIC events that cause the hart to resume execution after Wait for Interrupt (WFI) Instruction
>    4. Synchronous Exception Handling
>    5. Returns from Handlers
> 9. Interrupt Handling Software
>    1. Interrupt Stack Software Conventions
>    2. Inline Interrupt Handlers and "Interrupt Attribute" for C
> 10. Calling C-ABI Functions as Interrupt Handlers
>     1. C-ABI Trampoline Code
>     2. Revised C-ABI for Embedded RISC-V
>     3. Analysis of Worst-Case Interrupt Latencies for C-ABI Trampoline
> 11. Interrupt-Driven C-ABI Model
> 12. Alternate Interrupt Models for Software Vectoring
>     1. gp Trampoline to Inline Interrupt Handlers in Single Privilege Mode
>     2. Trampoline for Preemptible Inline Handlers
> 13. Managing Interrupt Stacks Across Privilege Modes
>     1. Software Privileged Stack Swap
>     2. Optional Scratch Swap CSR (xscratchcsw) for Multiple Privilege Modes
> 14. Separating Stack per Interrupt Level
>     1. Optional Scratch Swap CSR (xscratchcswl) for Interrupt Levels
> 15. CLIC Interrupt ID ordering recommendations
>     1. CLIC-mode interrupt-map for systems retaining interrupt ID compatible with CLINT mode:
>     2. CLIC-mode interrupt-map recommendation for single-hart systems with PLIC/APLIC:
>     3. CLIC-mode interrupt-map recommendation for single-hart M/S/U systems without N extension with no PLIC/APLIC:
>     4. CLIC-mode interrupt-map recommendation for single-hart M-mode only or M/U mode
>
>     Appendix A: Appendix
>
>     - A.1. Prototype DTS Entry
>
> 16. Bibliography
>
> Index

使用的图形要么是明确免费提供的，要么是 RISC-V International 的资产，要么是用 Wavedrom 制作的。

> Graphics used are either explicitly available for free, are property of RISC-V International, or were created using Wavedrom.

## 1. 修订历史

## 2. 背景和动机

> 2\. Background and Motivation

“Smclic”核内中断控制器（CLIC）特权架构扩展旨在为 RISC-V 系统提供低延迟、向量化、抢占式的中断。激活后，CLIC 将取代原来的 RISC-V 基本本地中断方案。CLIC 有一个只需最少硬件的基本设计，但支持额外的扩展以提供硬件加速。CLIC 的目标是为各种软件 ABI 和中断模型提供支持，而无需影响高性能实现的复杂硬件。

> The "Smclic" Core-Local Interrupt Controller (CLIC) Privileged Architecture Extension is designed to provide low-latency, vectored, pre-emptive interrupts for RISC-V systems. When activated the CLIC subsumes and replaces the original RISC-V basic local interrupt scheme. The CLIC has a base design that requires minimal hardware, but supports additional extensions to provide hardware acceleration. The goal of the CLIC is to provide support for a variety of software ABI and interrupt models, without complex hardware that can impact high-performance implementations.

CLIC 还支持一种新的选择性硬件向量功能，允许用户优化每个中断以获得更快的响应或更小的代码大小。

> The CLIC also supports a new Selective Hardware Vectoring feature that allow users to optimize each interrupt for either faster response or smaller code size.

|注意|虽然目前的 CLIC 只提供硬件线程内中断控制，但未来可能还会支持将中断定向到同一个核芯内的硬件线程上，因此得名 CLIC（CLIC 也比 HLI 或 HIC 好听）。
|-|-

> |Note|While the current CLIC provides only hart-local interrupt control, future additions might also support directing interrupts to harts within a core, hence the name (also CLIC sounds better than HLIC or HIC).
> |-|-

### 2.1. 原始的 RISC-V 基本本地中断（CLINT 模式）

> 2.1. Original RISC-V basic local Interrupts (CLINT mode)

RISC-V 特权架构规范定义了 `xip`、`xie`、`mideleg` CSR 和中断行为。为这种 RISC-V 中断方案提供处理器间中断和定时器功能的一类简单中断控制器称为 CLINT。当 `xtvec.mode` 设置为 `00` 或 `01` 时，本规范将使用术语“CLINT 模式”。

> The RISC-V Privileged Architecture specification defines CSRs xip, xie, mideleg and interrupt behavior. A simple interrupt controller that provides inter-processor interrupts and timer functionalities for this RISC-V interrupt scheme has been called CLINT. This specification will use the term CLINT mode when xtvec.mode is set to either 00 or 01.

CLINT 模式支持中断抢占，但必须基于权限态。在任何时候，一个 RISC-V 硬件线程都运行在某个权限态。全局中断使能位 MIE/SIE/UIE 分别保存在 `mstatus`/`sstatus`/`ustatus` 寄存器中，控制是否可以对当前或更高的权限态进行中断；对于较低的权限态，中断始终被禁用。任何来自更高权限态且启用的中断将停止在当前权限态下的执行过程，并以更高权限态进入处理程序。每个权限态都有自己的中断状态寄存器（M 态的 `mepc`/`mcause`，S 态的 `sepc`/`scause`，U 态的 `uepc`/`ucause`）来支持抢占，或者通用于权限态 `x` 的 `xepc`。被更高权限态的中断抢占，也会把当前的权限态和中断使能状态推到更高权限态的 `xstatus` 寄存器中的 `xpp` 和 `xpie` 栈上。

> CLINT mode supports interrupt preemption, but only based on privilege mode. At any point in time, a RISC-V hart is running with a current privilege mode. The global interrupt enable bits, MIE/SIE/UIE, held in the mstatus/sstatus/ustatus registers respectively, control whether interrupts can be taken for the current or higher privilege modes; interrupts are always disabled for lower-privileged modes. Any enabled interrupt from a higher-privilege mode will stop execution at the current privilege mode, and enter the handler at the higher privilege mode. Each privilege mode has its own interrupt state registers (mepc/mcause for M-mode, sepc/scause for S-mode, uepc/ucause for U-mode) to support preemption, or generically xepc for privilege mode x. Preemption by a higher-privilege-mode interrupt also pushes current privilege mode and interrupt enable status onto the xpp and xpie stacks in the xstatus register of the higher-privilege mode.

`xtvec` 寄存器指定了中断模式和中断向量表的基址。WARL 的 `xtvec` 寄存器的低位表示支持的中断模型。将 `xtvec` 的模式设置为 CLINT 模式（`*00` 和 `*01`）表示使用基本向量模型，此时 4 字节（或更大）对齐的表基址保存在 `xtvec` 的高位，并将非向量化或向量化地转移到处理函数。

> The xtvec register specifies both the interrupt mode and the base address of the interrupt vector table. The low bits of the WARL xtvec register indicate what interrupt model is supported. The CLINT mode settings of xtvec mode (*00 and*01) indicate use of the basic interrupt model with either non-vectored or vectored transfer to a handler function, with the 4-byte (or greater) aligned table base address held in the upper bits of xtvec.

|注意|WARL 表示“Write Any, Read Legel”，表示可以尝试写入任何值，但实际上只会写入一些支持的值。
|-|-

> |Note|WARL means "Write Any, Read Legal" indicating that any value can be attempted to be written but only some supported values will actually be written.
> |-|-

|注意|值为 `11` 的 `xtvec` 模式设置和值为 `0000` 的新定义的 `xtvec` 子模式字段表示 CLIC 模式而非 CLINT 模式。详情请参考本规范中的 `xtvec` 部分。
|-|-

> |Note|The settings of xtvec mode with the value of 11 and a newly defined xtvec submode field with the value of 0000 indicate CLIC modes instead of CLINT modes. Refer to the xtvec section in this specification for details.
> |-|-

### 2.2. 对比 CLIC 模式和 CLINT 模式

> 2.2. CLIC mode compared to CLINT mode

CLINT 模式的中断控制器是一个小单元，它提供本地中断并管理软件、定时器和外部中断信号（`xip` 寄存器中的 `xsip`/`xtip`/`xeip` 信号）。这个基本的控制器还允许在 `xip` 寄存器的第 16 位及以上添加额外的自定义快速本地中断信号。

> A CLINT mode interrupt controller is a small unit that provides local interrupts and manages the software, timer, and external interrupt signals (xsip/xtip/xeip signals in the xip register). This basic controller also allows additional custom fast local interrupt signals to be added in bits 16 and up of the xip register.

本地中断的优先级是固定的。`xtvec` 模式可以被设置为所有的中断都是直接的，并将 pc 设置为相同的向量基址。`xtvec` 模式也可以被设置为所有的中断都使用由跳转指令组成的向量表定向。

> Priority for local interrupts is fixed. xtvec mode can be set so that all interrupts are direct and set the pc to the same vector base address. xtvec mode can also be set so that all interrupts are vectored using a vector table filled with jump instructions.

CLIC 允许软件控制中断模式、触发类型、优先级以及每个单独中断的 CLIC 模式向量行为。CLIC 模式的向量表保存地址，因此不受跳转指令 +/-1MB 的限制。CLIC 增加了对相同权限态的中断抢占（水平中断）的支持，以及旨在减少中断处理程序中的内存或 CSR 访问次数的额外支持。

> CLIC allows software to control interrupt mode, trigger type, priority, and a CLIC mode vectoring behavior for each individual interrupt. The CLIC mode vector table holds addresses so does not have the +/-1MiB jump instruction limitation. CLIC adds support for same privilege level interrupt preemption (horizontal interrupts) and additional support to reduce the number of memory or CSR accesses within an interrupt handler.

平台配置可能需要支持 CLINT 和 CLIC 中断模式之一或同时支持二者。

> Platform profiles may require support for either or both of the CLINT and CLIC interrupt modes.

### 2.3. 对比 CLIC 和 PLIC

> 2.3. CLIC compared to PLIC

标准的 RISC-V 平台级中断控制器（PLIC）提供集中式中断优先级排序，并在多个硬件线程之间路由共享的平台级中断，但只向每个硬件线程的每个权限态发送一个外部中断信号。

> The standard RISC-V platform-level interrupt controller (PLIC) provides centralized interrupt prioritization and routes shared platform-level interrupts among multiple harts, but sends only a single external interrupt signal per privilege mode to each hart.

PLIC 路由方案使用通知/声明/响应/完成序列将中断路由到各个硬件线程，这需要在中断处理程序中进行额外的内存访问。

> The PLIC routing scheme uses a notification/claim/response/completion sequence to route interrupts to individual harts which requires additional interrupt handler memory accesses.

CLIC 是对 PLIC 的补充。较小的单核系统可能只有一个 CLIC，而多核系统可能每核有一个 CLIC 再加上一个共享的 PLIC。PLIC 的 `xeip` 信号被每个核的 CLIC 视为线程本地的中断源。

> The CLIC complements the PLIC. Smaller single-core systems might have only a CLIC, while multicore systems might have a CLIC per-core and a single shared PLIC. The PLIC xeip signals are treated as hart-local interrupt sources by the CLIC at each core.

### 2.4. 对比 CLIC 和高级中断架构（AIA）

> 2.4. CLIC compared to Advanced Interrupt Architecture

高级中断架构（AIA）支持消息信号中断（MSI）和高级 PLIC（APLIC），目标是支持多个硬件线程，并支持虚拟化。与 CLIC 一样，可以配置所有中断（不仅仅是外部中断）的相对优先级。CLIC 的目标是每个核的核内中断控制，并可以选择为每个中断源提供一个单独的陷入入口地址、用可调的优先级阈值控制中断的抢占（嵌套），并支持减少背对背中断的上下文切换。

> Advanced interrupt Architecture (AIA) supports message-signaled interrupts (MSIs) and an Advanced PLIC (APLIC) and targeted to support multiple harts, and support for virtualization. Like CLIC, the relative priority of all interrupts (not just external) can be configured. CLIC is targeted at CLIC per-core and has the option to give each interrupt source a separate trap entry address, preemption (nesting) of interrupts with adjustable priority threshold control, and support for reduced context switching with back-to-back interrupts.

## 3. CLIC 概述

> 3\. CLIC Overview

本节介绍了核内中断控制器（CLIC）的概况，它接收中断信号并给出下一个要由硬件线程处理的中断。

> This section gives an overview for the Core-Local Interrupt Controller (CLIC) that receives interrupt signals and presents the next interrupt to be processed by the hart.

CLIC 支持每个硬件线程多达 4096 个中断输入。每个中断输入 *i* 有 4 个 8 位内存映射的控制寄存器：一个中断挂起位（`clicintip[i]`），一个中断使能位（`clicintie[i]`），中断属性（`clicintattr[i]`）以指定权限态和触发类型，以及用于指定级别和优先级的中断控制位（`clicintctl[i]`）。

> The CLIC supports up to 4096 interrupt inputs per hart. Each interrupt input i has four 8-bit memory-mapped control registers: an interrupt-pending bit (clicintip\[i\]), an interrupt-enable bit (clicintie\[i\]), interrupt attributes (clicintattr\[i\]) to specify privilege mode and trigger type, and interrupt control bits to specify level and priority (clicintctl\[i\]).

当前 16 个中断输入被保留给存在于 `xip` 和 `xie` 寄存器低 16 位的 CLINT 模式中断时，最多可以增加 4080 个本地中断。

> When the first 16 interrupt inputs are reserved for the CLINT mode interrupts present in the low 16 bits of the xip and xie registers, up to 4080 local interrupts can be added.

### 3.1. 中断抢占

> 3.1. Interrupt Preemption

CLIC 扩展了中断抢占功能，为每种权限态支持最多 256 个中断级别，其中编号较高的中断级别可以抢占编号较低的中断级别。中断级别 0 对应于中断处理程序之外的常规执行。级别 1-255 对应于中断处理程序级别。平台配置将决定必须支持多少个中断级别。

> The CLIC extends interrupt preemption to support up to 256 interrupt levels for each privilege mode, where higher-numbered interrupt levels can preempt lower-numbered interrupt levels. Interrupt level 0 corresponds to regular execution outside of an interrupt handler. Levels 1—​255 correspond to interrupt handler levels. Platform profiles will dictate how many interrupt levels must be supported.

具有较高中断级别的传入中断可以抢占在同一权限态下以较低中断级别运行的活动中断处理程序，只要中断在该权限态下被全局使能。

> Incoming interrupts with a higher interrupt level can preempt an active interrupt handler running at a lower interrupt level in the same privilege mode, provided interrupts are globally enabled in this privilege mode.

|注意|现有的 RISC-V 中断行为被保留，即较高权限态的传入中断可以抢占在较低权限态下运行的活动中断处理程序，而不考虑较低权限态的全局中断使能。
|-|-

> |Note|Existing RISC-V interrupt behavior is retained, where incoming interrupts for a higher privilege mode can preempt an active interrupt handler running in a lower privilege mode, regardless of global interrupt enable in lower privilege mode.
> |-|-

### 3.2. CLIC 和其他本地中断的交互

> 3.2. CLIC Interaction with Other Local Interrupts

CLIC 取代了以前在 `xip`/`xie` 的第 16 位及以上提供的基本本地中断的功能，因此这些中断在 `xip`/`xie` 中不再可见。

> The CLIC subsumes the functionality of the basic local interrupts previously provided in bits 16 and up of xip/xie, so these are no longer visible in xip/xie.

现有的定时器（`mtip`/`stip`/`utip`）、软件（`msip`/`ssip`/`usip`）和外部中断输入（`meip`/`seip`/`ueip`）被视为额外的本地中断源，其中的权限态、中断级别和优先级可以通过内存映射的 `clicintattr[i]` 和 `clicintctl[i]` 寄存器进行改变。

> The existing timer (mtip/stip/utip), software (msip/ssip/usip), and external interrupt inputs (meip/seip/ueip) are treated as additional local interrupt sources, where the privilege mode, interrupt level, and priority can be altered using memory-mapped clicintattr\[i\] and clicintctl\[i\] registers.

|注意|在 CLIC 模式下，这些信号的中断委托是通过改变 CLIC 中断属性寄存器（`clicintattr`）中的中断权限态实现的，就像其他 CLIC 中断输入一样。
|-|-

> |Note|In CLIC mode, interrupt delegation for these signals is achieved via changing the interrupt’s privilege mode in the CLIC Interrupt Attribute Register (clicintattr), as with any other CLIC interrupt input.
> |-|-

## 4. CLIC 的内存映射寄存器

> 4\. CLIC Memory-Mapped Registers

### 4.1. CLIC 内存映射

> 4.1. CLIC Memory Map

每个硬件线程都有一个单独的 CLIC，通过一个单独的地址区域访问。M 态下的 CLIC 内存映射区域必须被运行在硬件线程上的M态软件所访问。

> Each hart has a separate CLIC accessed by a separate address region. The M-mode CLIC memory map region must be made accessible to the M-mode software running on the hart.

|注意|总线内存映射或锁定的 PMP 条目可能会阻止特定硬件线程上的 M 态软件访问 CLIC 内存映射。
|-|-

> |Note|A bus memory map or locked PMP entries could prevent M-mode software on a particular hart from reaching the CLIC memory map.
> |-|-

|注意|对于保留的内存区域，没有规定具体的陷入行为。根据系统总线结构，系统可以忽略访问（例如，读零/忽略写）或引发总线错误（通常是不精确的中断），或其他一些特定于平台的行为。这里的“保留”注释意味着未来的标准可能会在其中放置额外的标准寄存器，因此不建议将该空间用于非标准功能。
|-|-

> |Note|For reserved memory regions, specific trap behavior is not specified. Depending on system bus architecture, the system can ignore the access (e.g., read zero/write ignored) or cause a bus error (usually imprecise interrupt), or some other platform-specific behavior. The "reserved" annotation here implies that future standards might place additional standard registers in that space, and so using the space for non-standard features is inadvisable.
> |-|-

M 态的基址和任何其他权限态的 CLIC 内存映射寄存器的基址是通过正在开发的一般 RISC-V 发现机制指定的。更多细节见 CLIC 参数部分。

> The base address of M-mode and the base addresses of any other privilege mode CLIC memory-mapped registers is specified via the general RISC-V discovery mechanism that is in development. See the CLIC Parameters section for additional detail.

CLIC 内存映射支持总计最多 4096 个中断输入。

> The CLIC memory map supports up to 4096 total interrupt inputs.

```plaintext
M-mode CLIC memory map
  Offset
  ###   0x0008-0x003F              reserved    ###
  ###   0x00C0-0x07FF              reserved    ###
  ###   0x0800-0x0FFF              custom      ###

  0x0000         1B          RW        cliccfg

  0x0040         4B          RW        clicinttrig[0]
  0x0044         4B          RW        clicinttrig[1]
  0x0048         4B          RW        clicinttrig[2]
  ...
  0x00B4         4B          RW        clicinttrig[29]
  0x00B8         4B          RW        clicinttrig[30]
  0x00BC         4B          RW        clicinttrig[31]

  0x1000+4*i     1B/input    R or RW   clicintip[i]
  0x1001+4*i     1B/input    RW        clicintie[i]
  0x1002+4*i     1B/input    RW        clicintattr[i]
  0x1003+4*i     1B/input    RW        clicintctl[i]
  ...
  0x4FFC         1B/input    R or RW   clicintip[4095]
  0x4FFD         1B/input    RW        clicintie[4095]
  0x4FFE         1B/input    RW        clicintattr[4095]
  0x4FFF         1B/input    RW        clicintctl[4095]
```

特权态的 CLIC 区域只暴露在 M 态 CLIC 区域中被配置为特权可访问的中断。

> Supervisor-mode CLIC regions only expose interrupts that have been configured to be supervisor-accessible via the M-mode CLIC region.

用户态的 CLIC 区域只暴露在 M 态 CLIC 区域中被配置为用户可访问的中断。

> User-mode CLIC regions only expose interrupts that have been configured to be user-accessible via the M-mode CLIC region.

S 态和 U 态 CLIC 区域的位置与 M 态 CLIC 区域的位置无关，其基址由平台规范指定，并通过该平台的发现机制可见。这些 CLIC 区域的基址必须开始于自然对齐的 4 KiB 边界。

> The location of the S-mode and U-mode CLIC regions are independent of the location of the M-mode CLIC region, and their base addresses are specified by the platform specification and made visible via the discovery mechanism for that platform. The base addresses of these CLIC regions must begin on naturally aligned 4KiB boundaries.

|注意|发现机制仍在开发中。
|-|-

> |Note|Discovery mechanisms are still in development.
> |-|-

8b、16b 和 32b 存储到 CLIC 内存映射的寄存器是原子性的，但是，没有规定各个字段更新生效的顺序。对于 RV64，还支持对 CLIC 内存映射寄存器的 64 位自然对齐内存访问，但 64b 访问可以按任何顺序分成两个 32b 的访问。

> 8b, 16b, and 32b stores to CLIC memory-mapped registers are atomic, however, there is no specified order in which the effects of the individual field updates take effect. For RV64, naturally aligned 64-bit memory accesses to the CLIC memory-mapped registers are additionally supported but 64b accesses can be broken into two 32b accesses in any order.

如果硬件不存在输入 *i*，相应的 `clicintip[i]`、`clicintie[i]`、`clicintattr[i]`、`clicintctl[i]` 内存位置体现为硬连线到零。

> If an input i is not present in the hardware, the corresponding clicintip\[i\], clicintie\[i\], clicintattr\[i\], clicintctl\[i\] memory locations appear hardwired to zero.

所有 CLIC 内存映射寄存器对 M 态可见。配置为 M 态中断的中断寄存器 `clicintip[i]`、`clicintie[i]`、`clicintattr[i]`、`clicintctl[i]` 不能从 S 态和 U 态访问。配置为 S 态中断的中断寄存器 `clicintip[i]`、`clicintie[i]`、`clicintattr[i]`、`clicintctl[i]` 不能 U 态访问。

> All CLIC-memory mapped registers are visible to M-mode. Interrupt registers clicintip\[i\], clicintie\[i\], clicintattr\[i\], clicintctl\[i\] configured as M-mode interrupts are not acessible to S-mode and U-mode. Interrupt registers clicintip\[i\], clicintie\[i\], clicintattr\[i\], clicintctl\[i\] configured as S-mode interrupts are not acessible to U-mode.

在 S 态下，任何不能被 S 态访问的中断 *i* 的 `clicintip[i]`、`clicintie[i]`、`clicintattr[i]`、`clicintctl[i]` 体现为硬连线到零。

> In S-mode, any interrupt i that is not accessible to S-mode appears as hard-wired zeros in clicintip\[i\], clicintie\[i\], clicintattr\[i\], and clicintctl\[i\].

同样，在 U 态下，任何不能被 U 态访问的中断 *i* 的 `clicintip[i]`、`clicintie[i]`、`clicintattr[i]`、`clicintctl[i]` 体现为硬连线到零。

> Likewise, in U-mode, any interrupt i that is not accessible to U-mode appears as hard-wired zeros in clicintip\[i\], clicintie\[i\], clicintattr\[i\], and clicintctl\[i\].

中断的权限态由 `cliccfg.nmbits` 和 `clicintattr[i].mode` 控制，如下文指定中断权限态部分所述。

> The privilege mode of an interrupt is controlled by both cliccfg.nmbits and clicintattr\[i\].mode as described in the Specifying Interrupt Privilege Mode section below.

> 不知道这段话在说什么。

> It is not intended that the interconnect to the CLIC memory-mapped interrupt regions be required to carry the privilege mode of the initiator. A possible implementation of the CLIC memory map would be to alias the same physical CLIC memory-mapped registers to different address ranges, with each address range given different permissions for each privilege mode. Interrupts configured as M-mode interrupts appear as hard-wired zeros in the S-mode address range. Likewise interrupts configured as M-mode or S-mode would appear as hard-wired zeros in the U-mode address range.

其目的是利用系统的标准内存保护机制，使每个权限态只能访问必要的地址区域。这可以使用微控制器系统中的 PMP，或者具有虚拟内存支持硬件线程中使用页表（和/或 PMP）来完成。

> The intent is that only the necessary address regions are made accessible to each privilege mode using the system’s standard memory protection mechanisms. This can be done either using PMPs in microcontroller systems, or page tables (and/or PMPs) in harts with virtual memory support.

CLIC 规范没有规定 CLIC 内存映射寄存器如何在 M/S/U 区域之间分割，也没有规定多个硬件线程的布局，因为这通常是一个平台问题，每个平台需要定义一个发现机制来确定内存映射位置。平台需要考虑的一些问题是选择允许有效的 PMP 和虚拟内存配置的区域。例如，可能希望每个 S/U 态的 CLIC 区域的基址是虚存页（4k）对齐的，这样它们就可以通过页表项进行映射。

> The CLIC specification does not dictate how CLIC memory-mapped registers are split between M/S/U regions as well as the layout of multiple harts as this is generally a platform issue and each platform needs to define a discovery mechanism to determine the memory map locations. Some considerations for platforms to consider are selecting regions that allow for efficient PMP and virtual memory configuration. For example, it may desired that the bases of each S/U-mode CLIC region is VM page (4k) aligned so they can be mapped through the TLBs.

### 4.2. CLIC 配置（`cliccfg`）

> 4.2. CLIC Configuration (cliccfg)

CLIC 有一个内存映射的 8 位全局配置寄存器 `cliccfg`，它定义了支持多少种权限态以及 `clicintctl[i]` 寄存器如何被细分为级别和优先级字段。

> The CLIC has a single memory-mapped 8-bit global configuration register, cliccfg, that defines how many privilege modes are supported and how the clicintctl\[i\] registers are subdivided into level and priority fields.

`cliccfg` 寄存器有两个 WARL 字段，一个 2 位 `nmbits` 字段，一个 4 位 `nlbits` 字段，加上两个保留位 WPRI--在当前规范中硬连接为 0。

> The cliccfg register has two WARL fields, a 2-bit nmbits field, and a 4-bit nlbits field, plus two reserved bits WPRI-hardwired to zero in current spec.

|注意|WPRI 意味着“写时保留数值，读时忽略数值”，表示整个读/写字段保留给未来使用。软件应该忽略从这些字段中读出的值，而在向同一寄存器的其他字段写值时，应该保留这些字段中的值。为了向前兼容，不提供这些字段的实现必须将它们硬连接为零。
|-|-

> |Note|WPRI means "Writes Preserve Values, Reads Ignore Values" indicating whole read/write fields are reserved for future use. Software should ignore the values read from these fields, and should preserve the values held in these fields when writing values to other fields of the same register. For forward compatibility, implementations that do not furnish these fields must hardwire them to zero.
> |-|-

```plaintext
cliccfg register layout

Bits  Field
7     reserved (WPRI 0)
6:5   nmbits[1:0]
4:1   nlbits[3:0]
  0   reserved (WPRI 0)
```

每个字段的详细解释在下面的章节中描述。

> Detailed explanation for each field are described in the following sections.

#### 4.2.1. 指定中断权限态

> 4.2.1. Specifying Interrupt Privilege Mode

2 位的 `cliccfg.nmbits` WARL 字段指定了为了表达一个输入 *i* 的权限态，物理设备在 `clicintattr[i].mode` 中实现了多少位。尽管 `cliccfg.nmbits` 字段总是 2 位宽，但这个字段中物理实现的位数可以少于 2 位（取决于支持多少种中断权限态）。

> The 2-bit cliccfg.nmbits WARL field specifies how many bits are physically implemented in clicintattr\[i\].mode to represent an input i's privilege mode. Although cliccfg.nmbits field is always 2-bit wide, the physically implemented bits in this field can be fewer than two (depending how many interrupt privilege-modes are supported).

例如，在只有 M 模式的系统中，只存在 M 模式，所以我们不需要任何额外的位来表示支持的权限态。在这种情况下，`clicintattr.mode` 中不需要物理实现位，因此 `cliccfg.nmbits` 是 0（即 `cliccfg.nmbits` 可以硬连接为 0）。

> For example, in M-mode-only systems, only M-mode exists so we do not need any extra bit to represent the supported privilege-modes. In this case, no physically implemented bits are needed in the clicintattr.mode and thus cliccfg.nmbits is 0 (i.e., cliccfg.nmbits can be hardwired to 0).

在支持 N 扩展的用户态中断的 M/U 模式系统中，`cliccfg.nmbits` 可以被设置为 0 或 1。如果 `cliccfg.nmbits`= 0，那么所有的中断都被当作 M 模式的中断处理。如果 `cliccfg.nmbits` = 1，那么 `clicintattr[i].mode` 寄存器的最高有效位（MSB）的值为 1，表示以 M 模式处理中断输入，而值为 0 表示以 U 模式处理中断。

> In M/U-mode systems with N-extension user-level interrupts support, cliccfg.nmbits can be set to 0 or 1. If cliccfg.nmbits = 0, then all interrupts are treated as M-mode interrupts. If the cliccfg.nmbits = 1, then a value of 1 in the most-significant bit (MSB) of a clicintattr\[i\].mode register indicates that interrupt intput is taken in M-mode, while a value of 0 indicates that interrupt is taken in U-mode.

同样，在支持所有 M/S/U 态中断的系统中，`cliccfg.nmbits` 可以被设置为 0、1 或 2 位来表示权限态。`cliccfg.nmbits` = 0 表示所有本地中断都以 M 态进行。`cliccfg.nmbits` = 1 表示 MSB 在 M 态（1）和 S 态（0）之间选择。`cliccfg.nmbits` = 2 表示每个 `clicintattr[i].mode` 寄存器的两个 MSB 使用与 `mstatus.mpp` 字段相同的编码表示中断的权限态。

> Similarly, in systems that support all M/S/U-mode interrupts, cliccfg.nmbits can be set to 0, 1, or 2 bits to represent privilege-modes. cliccfg.nmbits = 0 indicates that all local interrupts are taken in M-mode. cliccfg.nmbits = 1 indicates that the MSB selects between M-mode (1) and S-mode (0). cliccfg.nmbits = 2 indicates that the two MSBs of each clicintattr\[i\].mode register encode the interrupt’s privilege mode using the same encoding as the mstatus.mpp field.

|注意|裸露的 S 态（无 MMU，satp=0）可以在微控制器中使用，以允许中断的硬件授权脱离 M 态。裸露的 S 态已经被批准为特权架构的一部分。还有人提议增加 S 态的 PMP 支持，以允许在 S 态下运行的 RTOS 将自己与在 U 态下运行的任务隔离。提议的 N-扩展也将增加用户态的中断和陷阱，但还没有被批准，目前也没有推进。
|-|-

> |Note|Bare S-mode (no MMU, satp=0) can be used in microcontrollers to allow hardware delegation of interrupts out of M-mode. Bare S-mode has already been ratified as part of privileged architecture. There are also proposals to add S-mode PMP support to allow an RTOS running in S-mode to isolate itself from tasks running in U-mode. The proposed N-extension would also add user-mode interrupts and traps, but has not been ratified and is not currently being advanced.
> |-|-

```plaintext
Encoding for RISC-V privilege levels (mstatus.mpp)

Level  Encoding Name              Abbreviation
0      00       User/Application  U
1      01       Supervisor        S
2      10       Reserved
3      11       Machine           M
```

```plaintext
Interrupt Mode Table
priv-modes nmbits clicintattr[i].mode  Interpretation
       M      0       xx               M-mode interrupt

     M/U      0       xx               M-mode interrupt
     M/U      1       0x               U-mode interrupt
     M/U      1       1x               M-mode interrupt

   M/S/U      0       xx               M-mode interrupt
   M/S/U      1       0x               S-mode interrupt
   M/S/U      1       1x               M-mode interrupt
   M/S/U      2       00               U-mode interrupt
   M/S/U      2       01               S-mode interrupt
   M/S/U      2       10               Reserved (or extended S-mode)
   M/S/U      2       11               M-mode interrupt

   M/S/U      3       xx               Reserved
```

#### 4.2.2. 指定中断级别

> 4.2.2. Specifying Interrupt Level

4 位的 `cliccfg.nlbits` WARL 字段表示从 `clicintctl[i]` 的高位分配多少个来编码中断级别。

> The 4-bit cliccfg.nlbits WARL field indicates how many upper bits in clicintctl\[i\] are assigned to encode the interrupt level.

目前只支持 0 级别位或 8 级别位，目前其他值都是保留的。

> Only 0 or 8 level bits are currently supported, with other values currently reserved.

|注意|实际上，这使得控制位不是从只用于级别或只用于优先级。该设计支持更大范围的级别位设置，但目前还没有被标准化。
|-|-

> |Note|In effect, this switches the control bits from being used only for level or only for priority. The design supports a wider range of level-bit settings but this is not currently being standardized.
> |-|-

虽然中断级别是一个 8 位无符号整数，但实际分配或实现的位数可以少于 8 位。如上所述，分配的位数在 `cliccfg.nlbits` 中指定。实际执行的位数可以从 `cliccfg.nlbits` 和一个固定参数 `CLICINTCTLBITS`（数值在 0 到 8 之间）中得出，该参数指定了为中断级别和优先级实现的总位数。

> Although the interrupt level is an 8-bit unsigned integer, the number of bits actually assigned or implemented can be fewer than 8. As described above, the number of bits assigned is specified in cliccfg.nlbits. The number of bits actually implemented can be derived from cliccfg.nlbits and a fixed parameter CLICINTCTLBITS (with value between 0 to 8) which specifies bits implemented for both interrupt level and priority.

|注意|可用的级别位的数量可以通过从 `CLICINTCTLBITS` 减去模式位的数量来确定。
|-|-

> |Note|The number of available level bits can be determined by subtracting the number of mode bits from CLICINTCTLBITS.
> |-|-

如果实际分配或实现的位数少于 8，那么这些位就会被左对齐，并在缺少的低位上附加 1。例如，如果 `nlbits` > `CLICINTCTLBITS`，那么 8 位中断级别的低位被假定为全部为1。同样，如果 `nlbits` < 8，那么 8 位中断级别的低位被假定为全部为 1。下表显示了这些情况下的级别编码方式。

> If the actual bits assigned or implemented are fewer than 8, then these bits are left-justified and appended with 1’s for the lower missing bits. For example, if the nlbits > CLICINTCTLBITS, then the lower bits of the 8-bit interrupt level are assumed to be all 1s. Similarly, if nlbits < 8, then the lower bits of the 8-bit interrupt level are assumed to be all 1s. The following table shows how levels are encoded for these cases.

```plaintext
 #bits   encoding          interrupt levels
     0    ........                                                        255
     1    l.......                        127,                            255
     2    ll......           63,          127,            191,            255
     3    lll.....     31,   63,   95,    127,    159,    191,    223,    255
     4    llll....  15,31,47,63,79,95,111,127,143,159,175,191,207,223,239,255

 "l" bits are available variable bits in level specification
 "." bits are non-existent bits for level encoding, assumed to be 1
```

如果 `nlbits` = 0，那么所有的中断都被视为 255 级。

> If nlbits = 0, then all interrupts are treated as level 255.

`cliccfg` 设置的例子：

> Examples of cliccfg settings:

```plaintext
CLICINTCTLBITS nlbits clicintctl[i] interrupt levels
      0         2      ........     255
      1         2      l.......     127,255
      2         2      ll......     63,127,191,255
      3         3      lll.....     31,63,95,127,159,191,223,255
      4         1      lppp....     127,255
"." bits are non-existent bits for level encoding, assumed to be 1
"l" bits are available variable bits in level specification
"p" bits are available variable bits in priority specification
```

#### 4.2.3. 指定中断优先级

> 4.2.3. Specifying Interrupt Priority

`clicintctl[i]` 中不被配置为中断级别的部分的最低有效位是中断优先级，用于在同一权限态和中断级别的挂起且使能的中断中确定优先级。在给定的权限态和中断级别中，优先级最高的中断被优先处理。如果有多个具有相同最高优先级的挂起且使能的中断，则首先使用编号最高的中断。

> The least-significant bits in clicintctl\[i\] that are not configured to be part of the interrupt level are interrupt priority, which are used to prioritize among interrupts pending-and-enabled at the same privilege mode and interrupt level. The highest-priority interrupt at a given privilege mode and interrupt level is taken first. In case there are multiple pending-and-enabled interrupts at the same highest priority, the highest-numbered interrupt is taken first.

|注意|在相同的情况下，编号最高的中断命中（当权限态、级别和优先级都相同时）。这与 CLINT 中断模式下的情况相同，但与 PLIC 不同。
|-|-

> |Note|The highest numbered interrupt wins in a tie (when privilege mode, level and priority are all identical). This is the same as in CLINT interrupt mode, but different than the PLIC.
> |-|-

注意，8 位中断级别是用来确定抢占（用于嵌套中断）的。相比之下，8位中断优先级并不影响抢占，只是在有多个具有相同中断级别的待处理中断时，才会被用作仲裁。

> Notice that the 8-bit interrupt level is used to determine preemption (for nesting interrupts). In contrast, the 8-bit interrupt priority does not affect preemption but is only used as a tie-breaker when there are multiple pending interrupts with the same interrupt level.

任何已实现的优先级位都被视为 8 位无符号整数的最高有效位，较低的未实现位被设置为 1。例如，如果有一个优先级位（`p111_1111`），中断可以被设置为优先级 127 或 255，如果有两个优先级位（`pp11_1111`），中断可以被设置为优先级 63、127、191 或 255。

> Any implemented priority bits are treated as the most-significant bits of a 8-bit unsigned integer with lower unimplemented bits set to 1. For example, with one priority bit (p111_1111), interrupts can be set to have priorities 127 or 255, and with two priority bits (pp11_1111), interrupts can be set to have priorities 63, 127, 191, or 255.

### 4.3. CLIC 中断挂起（`clicintip`）

> 4.3. CLIC Interrupt Pending (clicintip)

每个中断输入都有一个专门的中断挂起位（`clicintip[i]`），为了方便访问，在内存映射中占据一个字节。挂起位位于该字节的第 0 位。软件应该假定 `clicintip[i]=0` 表示没有中断等待，而 `clicintip[i]!=0` 表示有中断等待，以适应未来可能对 `clicintip` 字段的扩展。

> Each interrupt input has a dedicated interrupt pending bit (clicintip\[i\]) and occupies one byte in the memory map for ease of access. The pending bit is located in bit 0 of the byte. Software should assume clicintip\[i\]=0 means no interrupt pending, and clicintip\[i\]!=0 indicates an interrupt is pending to accomodate possible future expansion of the clicintip field.

中断陷入发生的条件必须在 `clicintip` 中的中断开始或结束挂起的一定时间内确定，但与 MIP/MIE CSR 不同的是，clicintie 或 clicintip 在显式写入 `clicintip` 或 `clicintie` 后不一定会立即生效。

> The conditions for an interrupt trap to occur must be evaluated in a bounded amount of time from when an interrupt becomes, or ceases to be, pending in clicintip, but unlike the MIP/MIE CSRs, there is no requirement that clicintie or clicintip are evaluated immediately following an explicit store to clicintip or clicintie.

> 不知道这段话在说什么。

> When the input is configured for level-sensitive input, the clicintip\[i\] bit reflects the value of an input signal to the interrupt controller after any conditional inversion specified by the clicintattr\[i\] field, and software writes to the bit are ignored. Software clears the interrupt at the source device.

如果输入被配置为边缘敏感输入，`clicintip[i]` 是一个可读可写的寄存器，既可由硬件中断输入更新也可由软件更新。在中断输入上观察到适当极性的边沿后，由硬件设置该位，这由 `clicintattr[i]` 字段决定。当一个中断在向量模式下被服务，硬件会清除相关的中断等待位。请看 `xtvec` 一节关于硬件清零的更多细节。软件写入可以通过写入内存映射的寄存器直接设置或清除边缘触发的挂起位。当访问 `xnxti` 的 CSR 指令包括写入时，边缘触发的挂起位也可以被清除。

> When the input is configured for edge-sensitive input, clicintip\[i\] is a read-write register that can be updated both by hardware interrupt inputs and by software. The bit is set by hardware after an edge of the appropriate polarity is observed on the interrupt input, as determined by the clicintattr\[i\] field. Hardware clears the associated interrupt pending bit when an interrupt is serviced in vectored mode. See additional detail on hardware clearing in the xtvec section. Software writes can set or clear edge-triggered pending bits directly by writes to the memory-mapped register. Edge-triggered pending bits can also be cleared when a CSR instruction that accesses xnxti includes a write.

|注意|为了提高性能，当选择和服务一个向量中断时，硬件将自动清除相应的边缘触发的挂起位，所以软件不需要在服务程序中清除挂起位。
|-|-

> |Note|To improve performance, when a vectored interrupt is selected and serviced, the hardware will automatically clear a corresponding edge-triggered pending bit, so software doesn’t need to clear the pending bit in the service routine.
> |-|-

相反，当选择非向量（共用代码）中断时，硬件不会自动清除边沿触发的挂起位。

> In contrast, when a non-vectored (common code) interrupt is selected, the hardware will not automatically clear an edge-triggered pending bit.

|注意|在非向量模式下，要清楚一个边沿触发的挂起位，软件应该使用包含写入的 CSR 指令访问 `xnxti`。这方面的其他细节在 `xnxti` 部分有描述。
|-|-

> |Note|Software is expected to use a CSR instruction that accesses xnxti that includes a write to clear an edge-triggered pending bit in non-vectored mode. Additional detail on this is described in the xnxti section.
> |-|-

在 `clicintattr[i]` 中从电平敏感模式切换到边沿触发模式时，`clicintip[i]` 中的值是未定义的。

> The value in the clicintip\[i\] is undefined when switching from level-sensitive mode to edge-triggered mode in clicintattr\[i\].

|注意|电平敏感模式下，软件不能依靠在边沿触发模式下使用的底层 `clicintip[i]` 寄存器位保存状态。
|-|-

> |Note|Software cannot rely on the underlying clicintip[i] register bits used in edge-triggered mode to hold state while in level-sensitive mode.
> |-|-

### 4.4. CLIC 中断使能（clicintie）

> 4.4. CLIC Interrupt Enable (clicintie)

每个中断输入都有一个专门的中断使能位（`clicintie[i]`），为了便于访问，在内存映射中占用一个字节。这个控制位是可读可写的，用于使能/失能对应的中断。使能位位于该字节的第 0 位。软件应该假定 clicintie\[i\]=0 表示没有使能中断，而 clicintie\[i\]!=0 表示使能了中断，以适应未来可能对 clicintie 字段的扩展。

> Each interrupt input has a dedicated interrupt-enable bit (clicintie\[i\]) and occupies one byte in the memory map for ease of access. This control bit is read-write to enable/disable the corresponding interrupt. The enable bit is located in bit 0 of the byte. Software should assume clicintie\[i\]=0 means no interrupt enabled, and clicintie\[i\]!=0 indicates an interrupt is enabled to accomodate possible future expansion of the clicintie field.

|注意|`clicintie[i]` 是单独的使能位，而 `xstatus`.`xie` 是当前权限态的全局使能位。因此，如果要在当前的权限态下启用一个中断 `i`，`clicintie[i]` 和 `xstatus`.`xie` 都必须置位。
|-|-

> |Note|clicintie\[i\] is the individual enable bit while xstatus.xie is the global enable bit for the current privilege mode. Therefore, for an interrupt i to be enabled in the current privilege mode, both clicintie\[i\] and xstatus.xie have to be set.
> |-|-

|注意|相反，由于 `xstatus`.`xie` 根据 RISC-V 的惯例只在当前权限态下生效，只要 `clicintie[i]` 被设置，来自更高权限模式的中断 `i` 就会被使能（不管 `xstatus`.`xie` 在更高权限模式下的设置如何）。
|-|-

> |Note|In contrast, since xstatus.xie only takes effect in the current privilege mode according to RISC-V convention, an interrupt i from a higher privilege mode is enabled as long as clicintie\[i\] is set (regardless of the setting of xstatus.xie in the higher privilege modes).
> |-|-

### 4.5. CLIC 中断属性（`clicintattr`）

> 4.5. CLIC Interrupt Attribute (clicintattr)

这是一个 8 位 WARL 读写寄存器，用于指定每个中断的各种属性。

> This is an 8-bit WARL read-write register to specify various attributes for each interrupt.

```plaintext
  clicintattr register layout

  Bits    Field
  7:6     mode
  5:3     reserved (WPRI 0)
  2:1     trig
  0       shv
```

1 位 `shv` 字段用于可选的硬件向量。如果 `shv` 为 0，它将这个中断指定为非向量量中断，从而跳转到 `xtvec` 的共用代码。如果 `shv` 为 1，它把这个中断指定为硬件向量，因此它自动跳转到 `xtvt` CSR 中指定的陷入处理函数指针。这个功能允许一些中断全部跳到 `xtvec` 中持有的一个共用的基地址，而其他的中断则通过额外的 `xtvt` CSR 所指向的表用硬件定向。

> The 1-bit shv field is used for Selective Hardware Vectoring. If shv is 0, it assigns this interrupt to be non-vectored and thus it jumps to the common code at xtvec. If shv is 1, it assigns this interrupt to be hardware vectored and thus it automatically jumps to the trap-handler function pointer specified in xtvt CSR. This feature allows some interrupts to all jump to a common base address held in xtvec, while the others are vectored in hardware via a table pointed to by the additional xtvt CSR.

|注意|如果 NVBITS 为 0，可选的中断硬件向量功能没有实现，因此 `shv` 字段显示为 0（WARL 0）。
|-|-

> |Note|if NVBITS is 0, the selective interrupt hardware vectoring feature is not implemented and thus shv field appears hardwired to zero (WARL 0).
> |-|-

2 位 `trig` WARL 字段规定了每个中断输入的触发类型和极性。位 1，`trig[0]`，被定义为“边沿触发”（0：电平触发，1：边沿触发）；位 2，`trig[1]`，被定义为“负边”（0：正边，1：负边）。更具体地说，可以有四种可能的组合：正电平触发，负电平触发，上升沿触发和下降沿触发。

> The 2-bit trig WARL field specifies the trigger type and polarity for each interrupt input. Bit 1, trig\[0\], is defined as "edge-triggered" (0: level-triggered, 1: edge-triggered); while bit 2, trig\[1\], is defined as "negative-edge" (0: positive-edge, 1: negative-edge). More specifically, there can be four possible combinations: positive level-triggered, negative level-triggered, positive edge-triggered, and negative edge-triggered.

|注意|有些实现可能希望保存这些位，以便只支持某些触发类型。在这种情况下，这些位会变成硬接线的固定值（WARL）。
|-|-

> |Note|Some implementations may want to save these bits so only certain trigger types are supported. In this case, these bits become hard-wired to fixed values (WARL).
> |-|-

2 位 `mode` WARL 字段指定了该中断在哪种权限态下运行。这个字段是可写的，对 `cliccfg.nmbits` 的写入不会改变它，但读和隐式读其值是上面中断态表中指定的解释。

> The 2-bit mode WARL field specifies which privilege mode this interrupt operates in. This field is writable and is unchanged by writes to cliccfg.nmbits but the read and implicit read value is the interpretation as specified in the Interrupt Mode Table above.

|注意|为了安全起见，`mode` 字段只能被设置为等于或低于当前运行的权限级别的权限。
|-|-

> |Note|For security purpose, the mode field can only be set to a privilege level that is equal to or lower than the currently running privilege level.
> |-|-

### 4.6. CLIC 中断输入控制（`clicintctl`）

> 4.6. CLIC Interrupt Input Control (clicintctl)

`clicintctl[i]` 是一个 8 位内存映射的 WARL 控制寄存器，用于指定中断级别和中断优先级。这个寄存器中实际实现的位数由一个固定参数 CLICINTCTLBITS 指定，其值在 0 到 8 之间。实现的位在每个 8 位 `clicintctl[i]` 寄存器的最高有效位中保持左对齐，较低的未实现位被视为硬接线为 1。 这些控制位根据 CLIC 配置寄存器（`cliccfg.nlbits`）中的设置被解释为级别和优先级。

> clicintctl\[i\] is an 8-bit memory-mapped WARL control register to specify interrupt level and interrupt priority. The number of bits actually implemented in this register is specified by a fixed parameter CLICINTCTLBITS, which has a value between 0 to 8. The implemented bits are kept left-justified in the most-significant bits of each 8-bit clicintctl\[i\] register, with the lower unimplemented bits treated as hardwired to 1. These control bits are interpreted as level and priority according to the setting in the CLIC Configuration register (cliccfg.nlbits).

为了仲裁一个要提交给核芯的中断，CLIC 硬件将 `clicintattr.mode` 和 `clicintctl` 中的有效位合并成一个无符号整数，然后根据这个值在所有挂起且使能的中断中选择全局最大值。接下来，`cliccfg` 设置决定了如何将 `clicintctl` 的值分成中断级别和中断优先级。最后，这个被选中的中断的中断级别与相关权限态的中断级别阈值进行比较，以确定它是合格的还是被阈值屏蔽的（因此没有中断呈现）。

> To select an interrupt to present to the core, the CLIC hardware combines the valid bits in clicintattr.mode and clicintctl to form an unsigned integer, then picks the global maximum across all pending-and-enabled interrupts based on this value. Next, the cliccfg setting determines how to split the clicintctl value into interrupt level and interrupt priority. Finally, the interrupt level of this selected interrupt is compared with the interrupt-level threshold of the associated privilege mode to determine whether it is qualified or masked by the threshold (and thus no interrupt is presented).

|注意|在高权限态下命中一个中断会屏蔽低权限态下的任何中断，因为高权限态导致中断信号比任何低权限态的中断显得更紧急。
|-|-

> |Note|Selecting an interrupt at a high privilege mode masks any interrupt at a lower privilege mode since the higher-privilege mode causes the interrupt signal to appear more urgent than any lower-privilege mode interrupt.
> |-|-

#### 4.6.1. 中断输入识别号

> 4.6.1. Interrupt Input Identification Number

4096 个 CLIC 中断向量被赋予唯一的识别号，即 `xcause` 异常码（`exccode`）的值。如果需要保持向后兼容，CLINT 模式的中断保留其原来的 cause 值，而新的中断则从 16 开始编号。

> The 4096 CLIC interrupt vectors are given unique identification numbers with xcause Exception Code (exccode) values. When maintaining backward compatibility is desired, the CLINT mode interrupts retain their original cause values, while the new interrupts are numbered starting at 16.

|注意|早期的 CLINT 模式设计的本地中断直接连接到第 16 位和更高位，要从这种设计升级，这些本地中断现在可以作为 CLIC 的 16 号和更高的输入，以保留相同的中断ID。
|-|-

> |Note|When upgrading from an earlier CLINT mode design that had local interrupts attached directly to bits 16 and above, these local interrupts can be now attached as CLIC inputs 16 and above to retain the same interrupt IDs.
> |-|-

### 4.7. CLIC 中断触发器（`clicinttrig`）

> 4.7. CLIC Interrupt Trigger (clicinttrig)

可选的中断触发器（`clicinttrig[i]`）用于产生断点异常、进入调试模式或跟踪动作。支持的触发器的实际数量由 NUM_TRIGGER 参数指定。

> Optional interrupt triggers (clicinttrig\[i\]) are used to generate a breakpoint exception, entry into Debug Mode, or a trace action. The actual number of triggers supported is specified by the NUM_TRIGGER parameter.

每个中断触发器是一个 32 位内存映射的 WARL 寄存器，布局如下：

> Each interrupt trigger is a 32-bit memory-mapped WARL register with the following layout:

```plaintext
clicinttrig register layout

Bits    Field
31      enable
30:13   reserved (WARL 0)
12:0    interrupt_number
```

`interrupt_number` 字段选择哪一个中断输入作为这个中断触发器的来源。

> The interrupt_number field selects which number of interrupt input is used as the source for this interrupt trigger.

`enable` 控制位是可读写的，用于使能/失能这个中断触发器。

> The enable control bit is read-write to enable/disable this interrupt trigger.

该逻辑旨在与 RISC-V 调试规范中描述的 tmexttrigger.intctl 一起使用。

> This logic is intended to be used with tmexttrigger.intctl as described in the RISC-V debug specification.

如果有中断发生，并且中断代码与 `clicinttrig[i]`.interrupt_number 相匹配，并且相关的 `clicinttrig[i]`.enable 被设置，则向调试模块发出触发信号。

> A trigger is signaled to the debug module if an interrupt is taken and the interrupt code matches a clicinttrig\[i\].interrupt_number and the associated clicinttrig\[i\].enable is set.

## 5. CLIC 控制和状态寄存器

> 5\. CLIC CSRs

本节介绍了与 CLIC 相关的特定硬件控制和状态寄存器（CSR）。当处于 CLINT 中断模式时，其行为旨在与仅有 CLINT 模式的系统软件兼容。

> This section describes the CLIC-related hart-specific Control and Status Registers (CSRs). When in CLINT interrupt mode, the behavior is intended to be software compatible with CLINT-mode-only systems.

除非下文有不同的明确规定，否则在 CLIC 和 CLINT 模式之间切换时，CSR 状态位会保留其值。在 CLINT 模式下，新的 CLIC CSR 和新的 CLIC CSR 字段对于读和隐式读都显示为零。

> Unless explicitly specified differently below, CSR state bits retain their value when switching between CLIC and CLINT modes. New CLIC CSRs and new CLIC CSR fields appear to be zero for both reads and implicit reads in CLINT mode.

中断处理的 CSR 列在下面，这些 CSR 在 CLIC 模式的变化在后续章节中描述。

> The interrupt-handling CSRs are listed below, with changes and additions for CLIC mode described in the following sections.

```plaintext
       Number  Name         Description
       0xm00   xstatus      Status register
       0xm02   xedeleg      Exception delegation register
       0xm03   xideleg      Interrupt delegation register (INACTIVE IN CLIC MODE)
       0xm04   xie          Interrupt-enable register     (INACTIVE IN CLIC MODE)
       0xm05   xtvec        Trap-handler base address / interrupt mode
 (NEW) 0xm07   xtvt         Trap-handler vector table base address
       0xm40   xscratch     Scratch register for trap handlers
       0xm41   xepc         Exception program counter
       0xm42   xcause       Cause of trap
       0xm43   xtval        Bad address or instruction
       0xm44   xip          Interrupt-pending register    (INACTIVE IN CLIC MODE)
 (NEW) 0xm45   xnxti        Interrupt handler address and enable modifier
 (NEW) 0xr46   xintstatus   Current interrupt levels
 (NEW) 0xm47   xintthresh   Interrupt-level threshold
 (NEW) 0xm48   xscratchcsw  Conditional scratch swap on priv mode change
 (NEW) 0xm49   xscratchcswl Conditional scratch swap on level change

         m is the nibble encoding the privilege mode (M=0x3, S=0x1, U=0x0)
         r is the nibble encoding read-only along with the privilege mode (M=0xF, S=0xD, U=0xC)
         NOTE: Not all registers exist in all modes
```

### 5.1. `xstatus` CSR 的变化

> 5.1. Changes to xstatus CSRs

当处于 CLINT 中断模式时，`xstatus` 寄存器的行为没有改变（即向后兼容 CLINT 模式）。当处于 CLIC 模式时，`xstatus` 中的 `xpp` 和 `xpie` 现在可以通过 `xcause` 寄存器中的字段访问。

> When in CLINT interrupt mode, the xstatus register behavior is unchanged (i.e., backwards-compatible with CLINT mode). When in CLIC mode, the xpp and xpie in xstatus are now accessible via fields in the xcause register.

### 5.2. 代理（`xedeleg`/`xideleg`）CSR 的变化

> 5.2. Changes to Delegation (xedeleg/xideleg) CSRs

在 CLIC 模式下，中断属性寄存器的 `mode` 字段（`clicintattr[i].mode`）指定了处理每个中断的权限态，因此 `xideleg`
 CSR 在 CLIC 模式下不再有效。在 CLIC 和 CLINT 中断模式之间切换时，`xideleg` CSR 仍然可以访问，并且状态位保留其值。

> In CLIC mode, the mode field in Interrupt Attribute Register (clicintattr\[i\].mode) specifies the privilege mode in which each interrupt should be taken, so the xideleg CSR ceases to have effect in CLIC mode. The xideleg CSR is still accessible and state bits retain their values when switching between CLIC and CLINT interrupt modes.

由 `xedeleg` 指定的异常代理在 CLIC 模式下与 CLINT 模式下的功能相同。

> Exception delegation specified by xedeleg functions the same in CLIC mode as in CLINT mode.

### 5.3. `xie`/`xip` CSR 的变化

> 5.3. Changes to xie/xip CSRs

`xie` CSR 在 CLIC 模式下硬连线到零，由单独的内存映射的中断使能（`clicintie[i]`）取代。

> The xie CSR appears hardwired to zero in CLIC mode, replaced by separate memory-mapped interrupt enables (clicintie\[i\]).

`xip` CSR 在 CLIC 模式下硬连线到零，由单独的内存映射的中断挂起（`clicintip[i]`）取代。

> The xip CSR appears hardwired to zero in CLIC mode, replaced by separate memory-mapped interrupt pendings (clicintip\[i\]).

对 `xie`/`xip` 的写入将被忽略，不会被捕获（即没有访问错误）。`xie`/`xip` 在 CLIC 模式下总是显示为零。

> Writes to xie/xip will be ignored and will not trap (i.e., no access faults). xie/xip always appear to be zero in CLIC mode.

在同时支持 CLINT 和 CLIC 模式的系统中，`xie` 和 `xip` 中的状态位在模式间切换时保留其值。

> In systems that support both CLINT and CLIC modes, the state bits in xie and xip retain their value when switching between modes.

### 5.4. 用于 CLIC 的 `xtvec` CSR 新模式

> 5.4. New xtvec CSR Mode for CLIC

CLIC 中断处理模式被编码为现有 xtvec WARL 寄存器中的新状态，其中`xtvec`.`mode`（两个最低有效位）为 `11`，位 `xtvec`\[5:2\]（`xtvec`.`submode`）为 0。`xtvec`.`submode` 的其他编码被保留下来供将来使用。陷入向量基址被指定为 `xtvec` 的高 XLEN-6 位（`base`），外加低 6 位的零，这限制了在 64 字节或更大的 2 次方边界上对齐。

> The CLIC interrupt-handling mode is encoded as a new state in the existing xtvec WARL register, where xtvec.mode (the two least-significant bits) is 11, and bits xtvec[5:2] (xtvec.submode) are zero. The other encodings of xtvec.submode are reserved for future use. The trap vector base address is specified as the upper XLEN-6 bits of xtvec (base) with six lower zero bits appended, which constrains alignment on a 64-byte or larger power-of-two boundary.

```plaintext
 CLIC mode xtvec register layout

  Bits          Field
  XLEN-1:6      base (WARL)
  5:2           submode (WARL)
  1:0           mode (WARL)
```

|注意|同时实现 CLIC 和 CLINT 模式的系统可以，但没必要在这两种模式下将 `mtvec` 的对齐限制在 64 字节边界。
|-|-

> |Note|Systems implementing both CLIC and CLINT mode may, but are not required to, limit alignment of mtvec to 64-byte boundaries in both modes.
> |-|-

如果系统同时支持这两种模式，当 `mtvec.mode` 被设置为 `11`，并且 `mtvec.submode` 被设置为 `0000` 时，所有权限态都在 CLIC 模式下运行。在 CLIC 模式下，较低权限模式下的 `xtvec`.`mode` 和 `xtvec`.`submode` 是可写的，但读取或隐式读取时分别显示为 `11` 和 `0000`。

> If a system supports both modes, when mtvec.mode is set to 11 and mtvec.submode is set to 0000, all privilege modes operate in CLIC mode. In CLIC mode, xtvec.mode and xtvec.submode in lower privilege modes are writeable but appear to be 11 and 0000 respectively when read or implicitly read in that mode.

如果系统同时支持这两种模式，当 `mtvec.mode` 被设置为 CLINT 模式（`mtvec.mode=00` 或 `mtvec.mode=01`）时，所有权限态都在 CLINT 模式下运行。在 CLINT 模式下，`xtvec`.`mode` 的两个位在低权限模式下都是可写的，但是 `xtvec`.`mode` 的第 1 位在该模式下被读取或隐式读取时显示为 `0`。`xtvec` 的操作和以前一样，每个权限模式可以独立设置它们的 CLINT 模式（直接或矢量）。

> If a system supports both modes, when mtvec.mode is set to a CLINT mode (mtvec.mode=00 or mtvec.mode=01), all privilege modes operate in CLINT mode. In CLINT mode, both bits of xtvec.mode are writeable in lower-privilege modes but xtvec.mode bit 1 appears to be 0 when read or implicitly read in that mode. xtvec operates as before where each privilege mode can set their CLINT mode (direct or vectored) independently.

|注意|尽管未来的 CLIC 版本可能会允许权限有不同的 `xtvec`.`mode` 设置，但目前所有的权限态要不都在 CLIC 模式下运行，要不都在在非 CLIC 模式下运行。如果将来 CLIC 或其他新的中断控制器规格有增加，这些约束可能会改变。
|-|-

> |Note|Although future CLIC versions may allow privileges to have different xtvec.mode settings, for now all privilege modes must run in either CLIC mode or all privilege modes must run in non-CLIC mode. These constraints might change if there are future additions to the CLIC or other new interrupt controller specs.
> |-|-

```plaintext
 (xtvec[5:0])
 submode mode  Action on Interrupt
    aaaa 00    pc := OBASE                       (CLINT non-vectored basic mode)
    aaaa 01    pc := OBASE + 4 * exccode         (CLINT vectored basic mode)

    0000 11                                      (CLIC mode)
               (non-vectored)
               pc := NBASE                              if clicintattr[i].shv = 0
                                                        || if NVBITS = 0
                                                           (vector not supported)

               (vectored)
               pc := M[TBASE + XLEN/8 * exccode)] & ~1  if clicintattr[i].shv = 1

    0000 10                                      Reserved
    xxxx 1?    (xxxx!=0000)                      Reserved

 OBASE = xtvec[XLEN-1:2]<<2   # CLINT mode vector base is at least 4-byte aligned.
 NBASE = xtvec[XLEN-1:6]<<6   # CLIC mode vector base is at least 64-byte aligned.
 TBASE = xtvt[XLEN-1:6]<<6    # Trap vector table base is at least 64-byte aligned.
```

在 CLIC 模式下，向 `clicintattr[i].shv` 写 `0`，将中断 `i` 设置为非向量式，使硬件线程跳转到 `xtvec` 的高 XLEN-6 位上保存的陷入处理程序地址，用于处理特权模式 `x` 中的所有异常和中断。同样，如果没有实现可选的硬件向量功能（NVBITS 为 `0`），所有中断为非向量的，行为相同。

> In CLIC mode, writing 0 to clicintattr\[i\].shv sets interrupt i to non-vectored, where the hart jumps to the trap handler address held in the upper XLEN-6 bits of xtvec for all exceptions and interrupts in privilege mode x. Similarly, if the selective hardware vectoring feature is not implemented (NVBITS is 0), all interrupts are non-vectored and behave the same.

另外，向 `clicintattr[i].shv` 写 `1` 将中断 `i` 设置为向量化。当这些中断命中时，硬件线程切换到处理程序的权限态，除了在此和特权规范中描述的陷入副作用（如更新 `xintstatus`、`xcause`、`xstatus` 字段，包括清除 `xstatus`.`xie`），还设置处理程序权限态的 `xcause` 的硬件向量位 ·、`xinhv`。此时，如果相关的中断挂起位被配置为边缘敏感输入，它将被硬件清除。然后，硬件线程从内存表中获取一个 XLEN 位的处理程序地址，其权限与处理程序的态相对应，其基址（TBASE）在 `xtvt`。陷入处理程序函数地址为 `TBASE+XLEN/8*exccode`。如果获取成功，硬件线程清除处理程序地址的低位，将 PC 设置为这个处理程序地址，然后清除处理程序权限态中 `xcause` 的 `xinhv` 位。整体效果是：

> On the other hand, writing 1 to clicintattr\[i\].shv sets interrupt i to vectored. When these interrupts are taken, the hart switches to the handler’s privilege mode, and besides the trap side effects described in this and the privileged specification (e.g. update xintstatus, xcause, xstatus fields including clearing xstatus.xie), also sets the hardware vectoring bit xinhv in xcause of the handler privilege mode. At this time, if the associated interrupt pending bit is configured for edge-sensitive input, it is cleared by hardware. The hart then fetches an XLEN-bit handler address with permissions corresponding to the handler’s mode from the in-memory table whose base address (TBASE) is in xtvt. The trap handler function address is fetched from TBASE+XLEN/8*exccode. If the fetch is successful, the hart clears the low bit of the handler address, sets the PC to this handler address, then clears the xinhv bit in xcause of the handler privilege mode. The overall effect is:

```plaintext
pc := M[TBASE + XLEN/8 * exccode] & ~1
```

```plaintext
           # Vector table layout for RV32 (4-byte function pointers)
  mtvt ->  0x800000 # Interrupt 0 handler function pointer
           0x800004 # Interrupt 1 handler function pointer
           0x800008 # Interrupt 2 handler function pointer
           0x80000c # Interrupt 3 handler function pointer

           # Vector table layout for RV64 (8-byte function pointers)
  mtvt ->  0x800000 # Interrupt 0 handler function pointer
           0x800008 # Interrupt 1 handler function pointer
           0x800010 # Interrupt 2 handler function pointer
           0x800018 # Interrupt 3 handler function pointer
```

|注意|CLINT 向量模式只是跳转到陷入向量表中的一个地址，而 CLIC 向量模式从表中读取一个处理函数地址，并在硬件中跳转到该地址。
|-|-

> |Note|The CLINT vectored mode simply jumps to an address in the trap vector table, while the CLIC vectored mode reads a handler function address from the table, and jumps to it in hardware.
> |-|-

|注意|向量表包含向量地址而不是指令，因为这能简化 C 语言的静态初始化。更具体地说，表中的项是简单的 XLEN 位函数指针。
|-|-

> |Note|The vector table contains vector addresses rather than instructions because it simplifies static initialization in C. More specifically, the entries in the table are simple XLEN-bit function pointers.
> |-|-

|注意|设计硬件向量位 `xinhv` 是为了支持获取表向量过程中发生的陷入可以恢复。
|-|-

> |Note|The hardware vectoring bit xinhv is provided to allow resumable traps on fetches to the trap vector table.
> |-|-

硬件只会在读取表向量操作中写 `xinhv` 位。`xinhv` 位可以由软件写入，包括在硬件向量没有生效的时候。除了在使用 `xret` 指令从异常返回时，`xinhv` 位没有任何作用。由于成功的硬件向量获取会清除 `xinhv`，如果前一个权限态的 `xinhv` 被设置，就意味着在前一个权限态表向量读取操作中发生了异常。所以前一个权限的 `xinhv` 被设置时，`xret` 将把 `xepc` 作为表项的地址而不是指令的地址。

> The xinhv bits are only written by hardware during the table vector read operation. The xinhv bits can be written by software, including when hardware vectoring is not in effect. The xinhv bit has no effect except when returning from an exception using an xret instruction. Since successful hardware vector fetches clear xinhv, if xinhv of the previous privilege mode is set, it implies an exception occurred during previous privilege mode table vector read operation. So when xinhv of the previous privilege is set, xret will treat xepc as the address of a table entry instead of the address of an instruction.

当从 `xret` 指令返回时，`xinhv` 位对行为的修改如下：

> When returning from an xret instruction, the xinhv bit modifies behavior as follows:

如果前一个权限模式的 `xinhv` 位被设置，硬件线程恢复对陷入处理程序的内存访问，以检索函数指针，用于与前一个权限态相应的向量。陷入处理程序的函数地址是从当前权限模式的 `xepc` 中获取的。如果获取成功，硬件线程清除处理程序地址的低位，将 PC 设置为这个处理程序地址，然后清除处理程序的权限态的 `xcause` 的 `xinhv` 位。

> If the xinhv bit of the previous privilege mode is set, the hart resumes the trap handler memory access to retrieve the function pointer for vectoring with permissions corresponding to the previous privilege mode. The trap handler function address is fetched from the current privilege mode’s xepc. If the fetch is successful, the hart clears the low bit of the handler address, sets the PC to this handler address, then clears the xinhv bit in xcause of the handler privilege mode.

```plaintext
/* MRET pseudo-code */
set_next_pc(exception_handler(cur_privilege, MRET, PC));

function exception_handler(cur_priv, xret, pc) {
  match (xret) {
...
      MRET =>  {
      let prev_priv = cur_priv;
      mstatus.MIE   = mstatus.MPIE;
      mstatus.MPIE  = 1;
      cur_priv      = mstatus.MPP;
      ... /* additional standard MRET behavior */

      let xepc = prepare_xret_target(Machine);

      if  get_xinhv_value(cur_priv)
      then {
        if (check_fetch_permissions(xepc) = Addr_OK)
            clear_inhv(cur_priv)           /* If table entry read successful, clear inhv of current privilege */
            next_pc = mem_read(xepc) & ~1; /* xepc contains an address of a table entry */
          } else {
            /* take table-fetch trap */
          }
        } else { /* Standard MRET behavior - xepc becomes next_pc */
          next_pc = xepc & ~1;
        }
      }
    },
...
}

function prepare_xret_target(p) =
  match p {
    Machine    => mepc,
    Supervisor => sepc,
    User       => uepc
  }

 function get_xinhv_value(p) =
  match p {
    Machine    => mcause.MINHV,
    Supervisor => if (haveSMode) then scause.SINHV else 0,
    User       => if (haveUMode & haveUModeInterrupts) then ucause.UINHV else 0;
  }
```

|注意|xRET 设置 `xinhv` 位时，通知硬件再次使用 xEPC 中的地址取表，以获得陷阱处理程序的地址，然后写入 PC，而不是直接将 xEPC 写入 PC。这种行为的目的之一是避免使更多权限层处理虚拟内存的关键代码路径复杂化。更多权限层不必区分 CLIC 向量表的读取和其他形式的数据页故障，可以使用完全相同的代码来处理它们。
|-|-

> |Note|The xinhv bit when set at xRET informs hardware to repeat the table fetch using the address in xEPC to obtain the address of the trap handler that is then written to the PC instead of directly writing xEPC to the PC. One of the goals of this behavior is to avoid complicating the critical code paths for handling virtual memory in the more-privileged layer. The more-privileged layer does not have to distinguish CLIC vector table reads from other forms of data page fault and can handle them using exactly the same code.
> |-|-

实现可能只支持 CLINT 或 CLIC 模式中的一种。如果只支持基本模式，那么对第 1 位的写入就会被忽略，它总是被设置为零（当前行为）。如果只支持 CLIC 模式，对第 1 位的写入也会被忽略，它总是被设置为 1。CLIC 模式将 `xtvec` 第 2-5 位硬连接为 0（假设不支持进一步的 CLIC 扩展）。

> Implementations might support only one of CLINT or CLIC mode. If only basic mode is supported, writes to bit 1 are ignored and it is always set to zero (current behavior). If only CLIC mode is supported, writes to bit 1 are also ignored and it is always set to one. CLIC mode hardwires xtvec bits 2-5 to zero (assuming no further CLIC extensions are supported).

出于权限检查的目的，检索硬件向量的函数指针的内存访问是在中断处理程序的权限态下的隐式获取，需要执行权限；不需要读权限。

> For permissions-checking purposes, the memory access to retrieve the function pointer for hardware vectoring is an implicit fetch at the privilege mode of the interrupt handler, and requires execute permission; read permission is irrelevant.

|注意|软件向量需要向量表的读取权限。
|-|-

> |Note|software vectoring will need vector table read permission.
> |-|-

如果在取表时出现访问异常，故障地址将写入 `xepc`，`xtval` 要么被设置为 0，要么被写入故障地址。

> If there is an access exception on the table fetch, xepc is written with the faulting address. xtval is either set to zero or written with the faulting address.

|注意|对于比较简单的系统，我们不要求故障地址写入 `xtval`。对于有分页需求的系统，故障地址应该写入 `xtval`，以简化页错误处理代码。
|-|-

> |Note|For simpler systems, we do not require that xtval is written with the faulting address. For systems with demand paging, xtval should be written with the faulting address to simplify page-fault handling code.
> |-|-

|注意|在取表过程中，如果异常与中断处理程序的权限级别相同，在这样的水平陷入中会丢失中断上下文。有趣的情况是垂直陷入，在这种情况下，一个高权限层会处理页错误或其他同步故障，用于低权限态的向量表访问。高权限层中的常规代码路径将希望使用 `xtval` 来确定在发生错误的虚拟地址以补充分页，但在返回故障上下文时通常不会恢复 `xtval`（可能是在一段时间和其他上下文运行后）。然而，在正常代码路径上使用 `xret` 之前，它将恢复 `xepc`（这里使用 x 表示更多的权限态）。这就是为什么在有分页需求的系统中，`xtval` 和 `xepc` 都推荐写入故障地址的理由。
|-|-

> |Note|Interrupted context is lost on horizontal traps during table fetch where exceptions are the same privilege level as the interrupt handler. The interesting case is vertical traps, where a more privileged layer is handling page faults or other synchronous faults for the less privileged mode vector table access. The regular code path in more privileged layer will want to use xtval to determine what bad virtual address to page in, but will not normally restore xtval when returning to faulting context (potentially after some time and other contexts have run). However, it will restore xepc (using x for more privileged mode here) before using xret on normal code path. This is a rationale for why both xtval and xepc are recommended to be written with the faulting address in systems with demand paging.
> |-|-

对向量表的内存写入需要一个指令屏障（*fence.i*），以保证它们在指令获取中是可见的。

> Memory writes to the vector table require an instruction barrier (fence.i) to guarantee that they are visible to the instruction fetch.

在 CLIC 模式下，同步异常陷入总是跳到 NBASE。

> In CLIC mode, synchronous exception traps always jump to NBASE.

### 5.5. 新增的 `xtvt` CSR

> 5.5. New xtvt CSRs

XLEN 位的 `xtvt` WARL CSR 持有陷入向量表的基地址，在 64 字节或更大的 2 的幂边界上对齐。实际的对齐方式可以通过向低位写 1 然后读回来来确定。`xtvt` 的低 6 位只有 0 有效。

> The xtvt WARL XLEN-bit CSR holds the base address of the trap vector table, aligned on a 64-byte or greater power-of-two boundary. The actual alignment can be determined by writing ones to the low-order bits then reading them back. Values other than 0 in the low 6 bits of xtvt are reserved.

在同时支持 CLINT 和 CLIC 模式的系统中，xtvt CSR 在基本模式下仍然可以访问（但没有任何作用）。

> In systems that support both CLINT and CLIC modes, the xtvt CSR is still accessible in basic mode (but does not have any effect).

### 5.6. `xepc` CSR 的变化

> 5.6. Changes to xepc CSRs

`xepc` CSR 在两种模式下的行为是相同的，捕获执行中断时的PC。在 CLIC 模式下，如果在取硬件向量期间出现访问异常，`xepc` CSR 还会保存故障地址。

> The xepc CSRs behave the same in both modes, capturing the PC at which execution was interrupted. In CLIC mode, the xepc CSR additionally may hold the faulting address if there is an access exception on the table fetch during hardware vectoring.

### 5.7. {dpc} CSR 的变化

> 5.7. Changes to {dpc} CSRs

对于隐式硬件向量表的获取，是否在表的读取上设置断点是可选实现。对于软件向量中使用的显式加载，watchpoint 任何加载正常生效。在 CLIC 模式下，如果允许断点在硬件向量过程中对表的获取进行捕获，那么 `dpc` CSR 还可以保存故障地址。如果允许断点在读表时被捕获，dret 应该尊重 `xinhv`。

> For implicit hardware vector table fetches, whether breakpoints trap on the table read is left as an implementation option. For explicit loads used in software vectoring, watchpoints operate as normal for any load. In CLIC mode, the dpc CSR additionally may hold the faulting address if breakpoints are allowed to trap on the table fetch during hardware vectoring. If breakpoints are allowed to trap on the table read, dret should honor xinhv.

### 5.8. `xcause` CSR 的变化

> 5.8. Changes to xcause CSRs

在 CLINT 和 CLIC 模式下，`xcause` CSR 在中断或同步陷入发生时被写入，记录中断或陷入的原因。对于 CLIC 模式，`xcause` 还被扩展以记录更多关于中断上下文的信息，有助于减少为 `xret` 指令保存和恢复该上下文的开销。CLIC 模式的 `xcause` 还增加了记录陷阱处理过程中的进展的状态。

> In both CLINT and CLIC modes, the xcause CSR is written at the time an interrupt or synchronous trap is taken, recording the reason for the interrupt or trap. For CLIC mode, xcause is also extended to record more information about the interrupted context, which is used to reduce the overhead to save and restore that context for an xret instruction. CLIC mode xcause also adds state to record progress through the trap handling process.

```plaintext
mcause
Bits   Field         Description
XLEN-1 Interrupt     Interrupt=1, Exception=0
   30  minhv         Set by hardware at start of hardware vectoring, cleared by hardware at end of successful hardware vectoring
29:28  mpp[1:0]      Previous privilege mode, same as mstatus.mpp
   27  mpie          Previous interrupt enable, same as mstatus.mpie
26:24  (reserved)
23:16  mpil[7:0]     Previous interrupt level
15:12  (reserved)
11:0   Exccode[11:0] Exception/interrupt code
```

`mcause.mpp` 和 `mcause.mpie` 字段是 `mstatus.mpp` 和`mstatus.mpie` 字段的镜像，绑定到 `mcause` 以减少上下文保存/恢复代码。

> The mcause.mpp and mcause.mpie fields mirror the mstatus.mpp and mstatus.mpie fields, and are aliased into mcause to reduce context save/restore code.

注意：在一个直接的实现中，在 mcause 中读或写 mstatus 字段 mpp/mpie 等同于读或写 mstatus 中的同名字段。

> Note: In a straightforward implementation, reading or writing mstatus fields mpp/mpie in mcause is equivalent to reading or writing the homonymous field in mstatus.

如果硬件线程当前以某种权限态（`pp`）在某种中断级别（`pil`）下运行，而一个已使能的中断在更高的权限态下的任何中断级别上挂起，或者如果在当前权限态下一个更高的中断级别挂起，并且中断在这个权限态下全局使能，那么执行会立即转移到一个以新中断的权限态（`x`）和中断级别（`il`）运行的处理程序。

> If the hart is currently running at some privilege mode (pp) at some interrupt level (pil) and an enabled interrupt becomes pending at any interrupt level in a higher privilege mode or if an interrupt at a higher interrupt level in the current privilege mode becomes pending and interrupts are globally enabled in this privilege mode, then execution is immediately transferred to a handler running with the new interrupt’s privilege mode (x) and interrupt level (il).

`xepc` CSR 被设置为被中断的应用程序代码或被抢占的中断处理程序的 PC，而 `xcause` 寄存器现在捕获先前的权限态（`pp`）、中断级别（`pil`）和中断使能（`pie`），以及 `exccode` 中的中断 id。

> The CSR xepc is set to the PC of the interrupted application code or preempted interrupt handler, while the xcause register now captures the previous privilege mode (pp), interrupt level (pil) and interrupt enable (pie), as well as the id of the interrupt in exccode.

为了在同时支持 CLINT 和 CLIC 模式的系统中实现向后兼容，当切换到 CLINT 模式时，新的 CLIC `xcause` 状态字段（`xinhv` 和 `xpil`）被清零。其他新的 CLIC `xcause` 字段，`xpp` 和 `xpie`，在 `xcause` CSR 中显示为零，但 `mstatus` 寄存器中相应的状态位不被清除。

> For backwards compatibility in systems supporting both CLINT and CLIC modes, when switching to CLINT mode the new CLIC xcause state fields (xinhv and xpil) are zeroed. The other new CLIC xcause fields, xpp and xpie, appear as zero in the xcause CSR but the corresponding state bits in the mstatus register are not cleared.

注意：目前，要么所权限态都在 CLIC 模式下运行，要么所有权限态都在非 CLIC 模式下运行，所以从 CLIC 模式切换到 CLINT 模式会导致所有权限态下的 `xinhv` 和 `xpil` 被清零。

> Note: For now all privilege modes must run in either CLIC mode or all privilege modes must run in non-CLIC mode so switching to CLINT mode from CLIC mode causes xinhv and xpil in all privilege modes to be zeroed.

在 CLIC 模式下，当被捕获时，`xcause` 具有 CLIC 格式，`xcause` 字段更新（`xinhv` 在硬件向量开始时由硬件设置，在硬件向量成功结束时被清除，其他情况下没有变化）。当不在 CLIC 模式时，`xcause` 具有 CLINT 模式的格式。

> In CLIC mode, when a trap is taken, xcause has the CLIC format and the xcause fields are updated (xinhv is set by hardware at start of hardware vectoring, cleared at end of successful hardware vectoring, no change otherwise). On the other hand, when not in CLIC mode, xcause has the CLINT mode format.

特权态 `scause` 寄存器只有一个 `spp` 位（表示用户/特权），作为 `sstatus.spp` 的镜像，而用户 `ucause` 寄存器没有 `upp` 位，因为中断只能来自用户态。

> The supervisor scause register has only a single spp bit (to indicate user/supervisor) mirrored from sstatus.spp, while the user ucause register has no upp bit as interrupts can only have come from user mode.

```plaintext
scause
 Bits    Field        Description
 XLEN-1 Interrupt     Interrupt=1, Exception=0
    30  sinhv         Set by hardware at start of hardware vectoring, cleared by hardware at end of successful hardware vectoring
    29  (reserved)
    28  spp           Previous privilege mode, same as sstatus.spp
    27  spie          Previous interrupt enable, same as sstatus.spie
 26:24  (reserved)
 23:16  spil[7:0]     Previous interrupt level
 15:12  (reserved)
 11:0   exccode[11:0] Exception/interrupt code

 ucause
 Bits    Field       Description
 XLEN-1 Interrupt    Interrupt=1, Exception=0
    30  uinhv        Set by hardware at start of hardware vectoring, cleared by hardware at end of successful hardware vectoring
 29:28  (reserved)
    27  upie         Previous interrupt enable, same as ustatus.upie
 26:24  (reserved)
 23:16  upil[7:0]    Previous interrupt level
 15:12  (reserved)
 11:0  exccode[11:0] Exception/interrupt code
```
