# Rust 教程第一课

## 课前介绍

先介绍一下直播课的课程设置。由于我们本次训练营很多同学都在之前的训练营做过一次或者多次 Rustlings 了，而且 Rustlings 本身难度不大，许多题目也是反复练习的类型，所以本次课程的重点不会放在 Rustlings 习题上，而是以介绍语法上的一些重点难点为主。包括胖指针、生命周期标注这种重点问题都会讲到。

### 理解 Rust

今天第一次课，首先我想谈一谈如何看待 Rust 语言的问题。

想必来听 Rust 课程的同学，都是对 Rust 感兴趣的。如今 Rust 在网上热度相当之高，号称编程语言原神；但是相比传统的工业界使用的语言比如 C++、Java，实践经验又相当至少。对于许多人尤其是工作的人来说，还是一个闻其名未见其实的东西。所以许多已经在实践中使用 Rust 的人就会经常被问到一个问题：Rust 究竟和 C++、Java 这样的语言有什么区别？

![rusting](rusting.jpg)

Rust 和 Java/C# 的区别可以直接套用 C++ 的套路，无非就是无 GC、无运行时、无虚拟机、值类型为主缓存更友好之类的。但是 Rust 和 C++ 的区别其实是很难回答的。最常见的说法还是 Rust 编译检查更多，所有权+生命周期管理之后抑制内存错误，运行时调试更少一类。但是比较深度的 C++ 用户经常对这样的论调抱有怀疑态度。就算 C++ 在语法和标准库方面不如 Rust 这样的新生代语言全面，但是 C++ 有超庞大的生态，而且本身也在持续改进。现代 C++ 已经添加了许多机制，也有许多非常强大的库和工具，可以在不运行或者自动试运行的情况下检查 C++ 代码中的风险和漏洞。而且有些工具不一定是编译器的一部分，不受编译器的工作条件限制，以至于甚至可以比 Rust 的语法检查更丰富更细致。如果正确使用甚至继续发展它们，那么是不是就足以抵消 Rust 编译器的检查能力呢？甚至更激烈的说法是 Rust 就无敌了吗？安全问题不全是内存和并发安全问题！是不是反过来 Rust 也必须依赖这些高级工具的能力呢？包括 C++ 之父本人现在也经常站在这种立场为 C++ 发声。

另一方面，C++ 用户中有另一种论调，就是认为 Rust 语法检查过分限制了程序员的能力，就是所谓的“不自由”论。包括我们训练营里有些工作的学员作为 C++ 用户也有这样的说法。对这种说法 Rust 用户常见的反应就是给他们科普，Rust 只要开启 unsafe 就可以去掉许多编译器检查啦，然后进一步科普 Rust unsafe 不是真的不安全哦，只是告诉 Rust 编译器，这个部分我作为程序员有能力自己保证，不劳费心，所以 unsafe Rust 是名字起错了之类。这种对话在网络上极度常见，相信关注 Rust 的同学一定都看过不止一次，我觉得我看了百八十次也是有的。

其实这种说法在历史上曾经反复地出现。较早的争论可能是要不要禁止使用 goto 语句。当 C 语言被发明出来的时候，它的语句是可以与汇编一一对应的，既然汇编里有 jmp ljmp，那么 C 语言里自然而然地需要 goto。最终虽然随着时代发展这样的争论逐渐淡化了，但是在嵌入式这样常年仅能使用纯粹 C 语言的领域使用 goto 的言论至今都依然存在。此后的类似情况甚至就发生在 C++ 本身，比如：

- C++ 能做的 C 语言都能做，C++ 又复杂混乱，为什么要用 C++ 呢？（linus 本人就持这种观点，所以 C++ 至今未能进入 Linux 内核）
- C with class 挺好的，而且这就是 C++ 的设计初衷，为什么要使用所谓的 C++ 风格？C++ 风格才是 C++ 跑偏的产物，C 就是正解！
- C++98、C++03 挺好的，我用了几十年了，C++11 加的什么乱七八糟东西，移动语义？我学不会。
- C++17 已经圆满了，C++20 特性都没一个编译器实现全了，我可不敢用。
- 啊？已经有 [C++26](https://zh.cppreference.com/w/cpp/compiler_support/26) 了吗，今年不是 2024 年么……
- ~~什么 [JDK22](https://www.oracle.com/cn/java/technologies/downloads/) 出了？我还在用 Java1.6 呢~~

祖师爷图灵他老人家已经证明了，所有图灵完全的机器都有相同的计算能力。那么汇编、C、C++、Rust，使他们成为不同语言的根源和本质究竟是什么呢？

我的观点是，C++ 和 Rust 作为高级语言的本质不是类或者安全性，而是“零开销抽象”这句口号。

不同的编程语言对于相同的程序表达不同，本质上是它们为程序提供不同的抽象。而 C、C++、Rust 这一系列的高级语言，额外要求在提供抽象的同时，不能带来运行时的开销。而不同的抽象，影响的不是生成程序的性能或者安全性，而是程序员的思维方式。

在这种观点下，可以圆润地解释全 unsafe 的 Rust 和 C++ 有何不同；解释现代 C++ 和 C with class 有何不同；以及解释上述所有问题。同时，它也终结使用何种语言的争论。因为思维方式是相当主观的事。不同的人完全可以适应不同的思维方式。不满足于现状，觉得自己没有达到理想工作状态的程序员可以选择学习新的语言或者新的语法来改变思维方式，以期改变编程能力；但是已经达到舒适状态的程序员当然可以维持熟悉的思维方式，专注于解决实际问题。选择何种编程语言，不是好与不好的对比，而是适应与不适应的对比。

我在这里举两个例子，来具体说明 C++ 和 Rust 在哪些抽象上有差异。

第一个是我特别爱举的例子，如果在场还有 22 年训练营的同学可能听过原话。C++ 和 Rust 上一个差异鲜明的抽象是对互斥锁的不同理解。

C++ 的[互斥锁](https://zh.cppreference.com/w/cpp/thread/mutex)是这个样子：

```c++
std::mutex mutex; // 锁对象
{
    std::lock_guard guard(mutex); // 控制上锁区域的 RAII 对象
    ...
}
```

Rust 的[互斥锁](https://doc.rust-lang.org/std/sync/struct.Mutex.html)是这个样子：

```rust
let data: Mutex<i32> = Mutex::new(0); // 锁对象，隐去了常与 Mutex 配合的 Arc
{
    let mut data = data.lock().unwrap(); // 控制上锁区域的 RAII 对象
    ...
}
```

抛去语法上的差异，这两份代码其实是相当接近的。但是这两份代码也展示了 C++ 和 Rust 在对互斥锁的理解上根本性的不同，即：C++ 的 `std::mutex` 锁住的是时间，它控制锁区域的代码片段只能被引用同一个锁对象的线程互斥地执行，而不管这个代码片段的具体内容；Rust 的 `Mutex` 锁住的是空间，它控制被包装的对象只能被引用同一个对象的线程互斥地访问，而不管是在多大的范围里。所以，如果采用 C++ 的抽象对应的思维方式，容易写出较少的上锁解锁次数，比如在一把锁里集中操作多个共享的变量，因为程序员心里清楚只要互斥操作发生在锁控制的区域内就是安全的。而采用 Rust 的抽象对应的思维方式，容易写出细粒度的多把锁，例如对象 A 先锁定执行互斥的状态变换，然后对象 B 锁定与 A 执行互斥的状态交互，然后 A 对象解锁 B 对象利用 A 传递的信息执行互斥的状态变换，最后 B 对象解锁；Rust 写这样的程序是自然而然的，C++ 操作多个重叠的锁区域对于程序员的心智负担就大多了。

同时，C++ 和 Rust 的锁抽象也是完全可以相互转化的。C++ 可以通过重新封装 Rust Mutex 的模板类直接实现出锁定数据的互斥锁。Rust 也可以通过锁定包含一组变量的元组来节约锁定操作，或者直接锁定零元元组 `()` 来实现代码段的互斥执行。所以，熟悉多种语言的程序员，甚至可以根据需求来定制使用的抽象，来降低实现特定功能的心智负担。

第二个例子，我想为大家证明，C++ 编译器并非没有能力找到未定义行为（Undefined Behavior, UB），而是在它的哲学或者说思维方式的指导下，主动选择放弃管理 UB 的。其实非常简单，在可编译期求值（constexpr）的函数中，不允许任何未定义行为。比如说，经典的类型双关代码：

```c++
constexpr float transmute(int i) {
    union U {
        int i;
        float f;
    } u{i};
    return u.f;
}

int main(int argc, char **argv) {
    constexpr float f = transmute(0);
    std::cout << f << std::endl;
    return 0;
}
```

> 扩展阅读：[类型双关](https://tttapa.github.io/Pages/Programming/Cpp/Practices/type-punning.html)。

显然，这个操作等价于 Rust 中的 `transmute`，是要标注 unsafe 的，而 C++ 编译器什么都不会说。但只要给这个代码加上 `constexpr`，C++ 编译器忽然就知道这个操作是不安全的了，会直接禁止它，你甚至没有任何办法能让它对这个操作放行！给联合体的哪一项赋值，就只能取出来哪一项，没有任何例外。可见 C++ 编译器完全有能力分析代码的数据流结构和生命周期，只是它通常不这么做罢了。C++ 编译器严格起来比 Rust 还要不近人情。在 C++20 之前甚至没有任何办法在编译期按位转换浮点数和定点数，C++20 加了 `std::bit_cast` 才解决这个问题。

综上所述，各位同学如果以后出去给别人介绍 Rust，不要直接上来复读内存安全性和无畏并发了，告诉对 Rust 好奇的人，Rust 的语法检查只是 Rust 的抽象的反映；Rust 的开发者希望通过所有权控制和生命周期标注来转变开发者的思维方式，从而让开发者能写出更正确的代码。如果通过 Rust 学会了这套抽象，那么在 C++ 或者别的任何语言中同样可以实践这套抽象来写出更正确的代码，不一定需要写 Rust。

这就是这节课我想讲的第一个内容，如何看待 Rust 语言。
