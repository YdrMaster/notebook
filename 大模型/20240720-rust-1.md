# Rust 教程第一课

## 课前介绍

先介绍一下直播课的课程设置。由于我们本次训练营很多同学都在之前的训练营做过一次或者多次 Rustlings 了，而且 Rustlings 本身难度不大，许多题目也是反复练习的类型，所以本次课程的重点不会放在 Rustlings 习题上，而是以介绍语法上的一些重点难点为主。包括胖指针、生命周期标注这种重点问题都会讲到。

### 理解 Rust

今天第一次课，首先我介绍一下我对 Rust 这种语言的认识。强调一下，我这里讲的是我的理解。对于 Rust 一般的理解，比如关于内存安全啊，无惧并发之类常见的说法我就不提了，反正随便在网上找一篇文章讲的都是一样的。首先，我想回顾一下网络上一些对 Rust 能力的探讨和争辩，介绍正反双方的观点，通过这些观点来引出我要讲的主题。

想必来听 Rust 课程的同学，都是对 Rust 感兴趣的。如今 Rust 在网上热度相当之高，号称编程语言原神；但是相比传统的工业界使用的语言比如 C++、Java，实践经验又相当至少。对于许多人尤其是工作的人来说，还是一个闻其名未见其实的东西。所以许多已经在实践中使用 Rust 的人就会经常被问到一个问题：Rust 究竟和 C++、Java 这样的语言有什么区别？

Rust 和 Java/C# 的区别可以直接套用 C++ 的套路，无非就是无 GC、无运行时、无虚拟机、值类型为主缓存更友好之类的。但是 Rust 和 C++ 的区别其实是很难回答的。最常见的说法还是 Rust 编译检查更多，所有权+生命周期管理之后抑制内存错误，运行时调试更少一类。但是比较深度的 C++ 用户经常对这样的论调抱有怀疑态度。就算 C++ 在语法和标准库方面不如 Rust 这样的新生代语言全面，但是 C++ 有超庞大的生态，而且本身也在持续改进。现代 C++ 已经添加了许多机制，也有许多非常强大的库和工具，可以在不运行或者自动试运行的情况下检查 C++ 代码中的风险和漏洞。而且有些工具不一定是编译器的一部分，不受编译器的工作条件限制，以至于甚至可以比 Rust 的语法检查更丰富更细致。如果正确使用甚至继续发展它们，那么是不是就足以抵消 Rust 编译器的检查能力呢？甚至更激烈的说法是 Rust 就无敌了吗？安全问题不全是内存和并发安全问题！是不是反过来 Rust 也必须依赖这些高级工具的能力呢？包括 C++ 之父本人现在也经常站在这种立场为 C++ 发声。

另一方面，C++ 用户中有另一种论调，就是认为 Rust 语法检查过分限制了程序员的能力，就是所谓的“不自由”论。包括我们训练营里有些工作的学员作为 C++ 用户也有这样的说法。对这种说法 Rust 用户常见的反应就是给他们科普，Rust 只要开启 unsafe 就可以去掉许多编译器检查啦，然后进一步科普 Rust unsafe 不是真的不安全哦，只是告诉 Rust 编译器，这个部分我作为程序员有能力自己保证，不劳费心，所以 unsafe Rust 是名字起错了之类。这种对话在网络上极度常见，相信关注 Rust 的同学一定都看过不止一次，我觉得我看了百八十次也是有的。

其实这种说法在历史上曾经反复地出现。较早的争论可能是要不要禁止使用 goto 语句。当 C 语言被发明出来的时候，它的语句是可以与汇编一一对应的，既然汇编里有 jmp ljmp，那么 C 语言里自然而然地需要 goto。最终虽然随着时代发展这样的争论逐渐淡化了，但是在嵌入式这样常年仅能使用纯粹 C 语言的领域使用 goto 的言论至今都依然存在。此后的类似情况甚至就发生在 C++ 本身，比如：

- C++ 能做的 C 语言都能做，C++ 又复杂混乱，为什么要用 C++ 呢？（linus 本人就持这种观点，所以 C++ 至今未能进入 Linux 内核）
- C with class 挺好的，而且这就是 C++ 的设计初衷，为什么要使用所谓的 C++ 风格？C++ 风格才是 C++ 跑偏的产物，C 就是正解！
- C++98、C++03 挺好的，我用了几十年了，C++11 加的什么乱七八糟东西，移动语义？我学不会。
- C++17 已经圆满了，C++20 特性都没一个编译器实现全了，我可不敢用。
- 啊？已经有 [C++26](https://zh.cppreference.com/w/cpp/compiler_support/26) 了吗，今年不是 2024 年么……
- ~~什么 [JDK22](https://www.oracle.com/cn/java/technologies/downloads/) 出了？我还在用 Java1.6 呢~~

祖师爷图灵他老人家已经证明了，所有图灵完全的机器都有相同的计算能力。那么汇编、C、C++、Rust，使他们成为不同语言的根源和本质究竟是什么呢？
