# learning-cxx 讲义

## 00_hello_world

首先是我们最熟悉的输出 hello world。现在还没讲到重载运算符，所以我们不讲原理，把 `std::cout` 直接当作一种语法现象来理解即可。C++ 的输出语法是在目标之间用左箭头 `<<` 连接：

```c++
std::cout << "Hello, InfiniTensor!" << std::endl;
```

后面的 `std::endl` 表示输出一个换行符。

我猜很多 C 语言用户习惯写 `printf`，C++ 里也可以直接用的。

```c++
printf("Hello, InfiniTensor!\n");
```

这个函数和 C++ 的流式语法有什么区别呢？

最主要的区别在于流式语法是类型安全的，比如在输出一个整数，一个小数都是正确的：

```c++
std::cout << 123 << std::endl
          << 3.1415926535 << std::endl;
```

但是 `printf` 需要你在格式串里直接标注输出的类型，如果类型标错：

```c++
printf("%d\n", 3.14); // %d 表示整数，却对应一个浮点数
```

虽然现代编译器能提出警告，但这不是语法错误，真的会把这个地址里的东西当作整数打印出来。

---

但是在可读性方面，流式语法就比较蠢了，比如我想输出一个 `a + b = c`，`printf` 形式写成：

```c++
printf("%d + %d = %d\n", 23, 19, 23 + 19);
```

这一看就是一段完整的话，很舒服。但是流式语法就得写成：

```c++
std::cout << 23 << " + " << 19 << " = " << 23 + 19 << std::endl;
```

支离破碎了属于是。

还有一个要注意的问题是流式格式化显示 bool 变量的格式：

```c++
std::cout << true << ' '<< false << std::endl;
```

可以看到它居然是当作整数显示的，相当奇怪。必须给它挂上流修饰符 `std::boolalpha` 才行：

```c++
std::cout << std::boolalpha << true << ' ' << false << std::endl;
```

但是这个流修饰符的行为又很奇怪，它的影响竟然是全局的！比如我写成：

```c++
{
    std::cout << std::boolalpha << true << ' ' << false << std::endl;
}
{
    std::cout << true << ' ' << false << std::endl;
}
```

可以观察到修饰一次之后，再输出给 std::cout 的所有 bool 全部被转化了。这种一不留神改了全局状态的设计实在是太逆天了。关于标准库中其他的流修饰符大家可以自行查看 [cppreference](https://zh.cppreference.com/w/cpp/io/manip)。虽然我的评价是能不用就算了。

所以在实践中，我们尽量使用 [{fmt}](https://fmt.dev) 库完成格式化输出。这个库有可能是 C++ 世界里使用最广泛的库之一了，功能相当强大。我们 RefactorGraph 项目里也是用的这个库。具体这个库的用法大家可以自己看文档学习。

由于这个库实在是太好用了，以至于它在 C++20 版本进入了标准。由于主流编译器实现这个库普遍比较晚，为了避免版本问题，我们就没有在习题里使用，这里可以展示一下它是怎么用的：

```c++
#include "../exercise.h"
#include <format>

int main(int argc, char **argv) {
    std::cout << std::format("Hello, {}!", "InfiniTensor") << std::endl
              << std::format("{} + {} = {}", 23, 19, 23 + 19) << std::endl;
    return 0;
}
```

推荐所有有条件选择项目运行环境的同学用这套输出。详细信息见 [cppreference](https://zh.cppreference.com/w/cpp/utility/format/format)。

最后要讲的是一些跟操作系统进程相关的东西，不是 C++ 本身的知识了。现代操作系统的进程设计中，为每个进程提供了 3 个管道，分别是标准输入、标准输出和标准错误。这个设定被映射到 C++ 标准库中，当然 C/Rust 或者其他语言，只要是能生成应用程序的基本都有这个设定。例如：

```c++
std::cout << "Hello, ";
std::cerr << "InfiniTensor!" << std::endl;
```

就是向输出流发送 `Hello,`，向错误流发送 `InfiniTensor!`。运行这个示例，看起来它们很正常地输出了。但是我们还是可以使用控制台的管道操作符来把标准输出和标准错误分别重定向到文件：

```shell
xmake run learn 0 > out.txt      # 输出流到文件，错误流到控制台
xmake run learn 0 > out.txt 2>&1 # 输出流和错误流都到文件
xmake run learn 0 2>err.txt      # 输出流到控制台，错误流到文件
```

好的，跟 C++ 输出相关的内容就讲这么多。标准输入流 `std::cin` 在我们的项目里完全用不到，这里就不讲了，需要的同学可以到 [cppreference](https://zh.cppreference.com/w/cpp/io/cin) 自学。

## 01_variable&add

第二题是变量定义。

做题还是非常容易的，随便给 x 一个定义就好。C++ 能出现的所有运算符见 [cppreference](https://zh.cppreference.com/w/cpp/language/expressions#.E8.BF.90.E7.AE.97.E7.AC.A6)。它们的优先级在这里列出了，大家可以自行学习。我们看到其中有两个算术运算符 `<<` 左移和 `>>` 右移，它们具有比计算更低的优先级，但是具有比比较和其他位运算更高的优先级，这意味着什么呢？

现在我们应该可以发现，C++ 的流操作实际上是流对象上复用这个左移运算符形成的语法！而流运算符的优先级是不会随着它操作的对象变化而变化的。所以，如果流操作里穿插了较低优先级的运算，比如：

```c++
std::cout << (1 << 10) << ' ' << (64 >> 3) << ' ' << (42 != 10) << std::endl;
```

必须要加上括号才是正确的。这样直接写出来似乎不难写对，然而当这些操作叠加在宏里的时候就不一定了，比如：

```c++
#define LEFT(x, w) (x) << (w)
    std::cout << LEFT(7, 10) << std::endl;
```

这就提醒我们宏很危险，流式操作也没它看起来那么安全，两个叠起来可以说是险象环生了。写 C++ 的时候一定要注意这些细节。

## 02_function

第 2 题我们来定义函数。函数的语法不复杂，返回值类型放前面，然后是一个名字，括号里是参数列表，每个参数都是类型加名字。基本所有语言的函数签名都差不多是这么定义的。然而对于没接触过 C/C++ 的同学来说，搞明白声明和定义就比较痛苦了。

简单来说，C/C++ 中，一个语法实体，无论是变量、类型、函数还是宏，都严格必须遵循先出现后使用的原则。只有已知是什么的东西才能出现在表达式里。这个函数只是存在在文件中是无法使用的，它必须要么出现在所有使用它的地方前面，比如：

```c++
int add(int a, int b) {
    return a + b;
}

int main(int argc, char **argv) {
    ASSERT(add(123, 456) == 123 + 456, "add(123, 456) should be 123 + 456");

    auto x = 1, y = 2;
    std::cout << x << " + " << y << " = " << add(x, y) << std::endl;
    return 0;
}
```

要么先利用一个声明来说清它是个什么东西，即：

```c++
int add(int, int);
```

这就是说 add 是一个接受 2 个 int 参数，返回一个 int 值的函数。到 `main` 里，就已知它是个什么函数了，可以编译下去，直到在下面看到定义。由于在声明的时候我们只关心 `add` 是什么东西，所以这些参数是不需要名字的。

> **NOTICE** 虽然把函数视作完全特殊的一种语法现象是很自然的，但是更好的理解是把函数、数组、指针和 `const`、`volatile` 都视作类型修饰符，它们共同作用在预定义和自定义类型上形成了对标识符的类型声明。阅读 [cppreference](https://zh.cppreference.com/w/cpp/language/declarations) 中的示例和链接来学习复杂类型解读法。

## 03_argument&parameter

这题讲的是经典的形参和实参问题。但是需要关注参数传递的问题：值传递、左值引用传递、左值常引用传递、右值引用传递、完美转发，各有什么特点，如何选择？

## 04_static

直接看 static 关键字的解释即可。

## 05_constexpr

这题要学习的是编译期计算的问题。使用 C++/Rust 要分清编译期和运行期。编译期计算有 2 种情况：

1. 编译器利用常量传播把运行期的常量计算优化到编译期；
2. 直接指定计算可能或者必须发生在编译期；

第一个是编译器的能力问题，现代编译器几乎都会选择传播所有常量。第二个则是语法现象，在 C++ 中，constexpr 关键字表示这种行为。当 constexpr 修饰函数时，表示这个函数可以在编译期执行。当 constexpr 修饰变量或者成员时，表示这个变量或者成员一定在编译期求值。所以在这一题中，需要同时在函数上和值上修饰 constexpr，才会导致所有计算发生在编译期。

同时也是因为计算发生在编译期，编译器执行代码的逻辑和运行时执行代码的逻辑不同，编译器会有一个最大递归深度限制。所以这个故意写成递归的斐波那契计算会算不了。所以这题的第一个解法是去掉 constexpr，这样解结果是对的但是会计算极慢。我们可以打印一下看看它在算啥：

```c++
#include "../exercise.h"

unsigned long long fibonacci(int i, int level = 0) {
    for (int j = 0; j < level; ++j) {
        std::cout << ": ";
    }
    std::cout << i << std::endl;
    switch (i) {
        case 0:
            return 0;
        case 1:
            return 1;
        default:
            return fibonacci(i - 1, level + 1) + fibonacci(i - 2, level + 1);
    }
}

int main(int argc, char **argv) {
    constexpr auto ANS_N = 5;
    auto ANS = fibonacci(ANS_N);
    std::cout << "fibonacci(" << ANS_N << ") = " << ANS << std::endl;
    return 0;
}
```

我这里改一改代码，我们看一个详细的过程。我给斐波那契函数加了一个参数 level，并且提供默认值 0，这样调用的时候就不用再传了，然后这个 level 每次递归就 +1，这就标记了递归的深度。然后搞一个小循环来打印一些缩进和标线出来好看。我们看一下这个结果：

```plaintext
5
: 4
: : 2
: : : 0
: : : 1
: : 3
: : : 1
: : : 2
: : : : 0
: : : : 1
: 3
: : 1
: : 2
: : : 0
: : : 1
fibonacci(5) = 5
```

可以看到为什么递归很慢。计算 5 需要计算 4 和 3，计算 4 又需要 3 和 2，所以相当于每多算一个数，计算量就大了接近 1 倍。

以及，我们再看这里计算的顺序。可以看到算 5 是先算 4 再算 3，但是算 4 的时候就是先算 2 再算 3 了。这说明什么 C++ 是不保证 `+` 两边求值的顺序的。实际上，C++ 只保证短路运算的顺序，其他的包括 `<<` 的顺序都是不保证的；函数调用的时候，函数的每个参数的求值顺序也是不保证的。所以**任何依赖参数求值顺序的操作都是未定义行为**。

当然，虽然很慢，但是这个计算最终是可以完成的。所以我在这里写的是修改一处使代码编译运行，但这可不一定能运行出结果😂。要快速算出结果的话，最简单的改法当然还是直接减小这个 N。这题大家只要理解为什么原来不能编译运行就行了。我看到群里有同学也自己探索了用模板特化的手法实现编译时的缓存来加速，这个方法是最好的，但是比较比较超纲我们这里就不讲了。

## 06_loop

第六题就是直白地考察数组初始化和 for 循环语法，以及展示一下斐波那契是怎么用缓存来加速的。说到缓存加速，顺便问大家一个问题，这个函数是一个纯函数吗？

（缓存不改变函数的“纯”性）

## 07_enum&union

第七题就是关于枚举和联合体。关于这两个东西本身我在内联的讲义上已经说的比较清楚了我就不再解释了。但是我要额外讲一下类型双关的问题。

最近我也更新了题目上的很多说明文字和阅读材料，已经做完的同学有时间的话可以回来读一读。

我们来看这段关于类型双关的[阅读材料](https://tttapa.github.io/Pages/Programming/Cpp/Practices/type-punning.html)。这里它又引用了 Wikipedia 的说法，说的是“类型双关是绕开编程语言类型系统的编程技术，以便实现在一般情况下无法实现的效果”。但是我使用“类型双关”这个词的时候通常取的是一个更狭窄的意思，就是我在习题说明里写的这句话：“将一种类型的值转换为另一种无关类型的值”。比如说在一般的机器上，C++ `int` 关键字对应的类型是 32 位有符号的整型，`float` 关键字对应的类型是 32 位满足 IEEE745 规范的浮点型，这两个类型就是所谓的无关类型。如果要把一个整型逐比特重新解释为浮点型，就要用到类型双关。

那这种类型双关怎么实现呢？

首先看这个转换：

```c++
float a = 2.5;
std::cout << (int) a << std::endl
          << static_cast<int>(a) << std::endl;
```

这两种转换都是在值之间转换，所以能够打印出 int 版本的 2。比特级别转换，最容易想到的是通过重新解释指针。

```c++
float a = 2.5, *p = &a;
std::cout << *(int *) p << std::endl
          << *reinterpret_cast<int *>(p) << std::endl;
```

我们会介绍到的类型双关全都是未定义行为，所以不用纠结这些代码的性质了。加入我们认为这些代码都按照字面意思生效，这个代码有什么问题呢？

float 和 int 是大小相同，对齐方式也相同的类型，因此直接转换看不出问题。但是如果转换的是大小不同、对齐不同的类型，直接指针转换本身就是错的了。比如：

```c++
const char *s = "Hello, InfiniTensor";
std::cout << *(int *) (s + 0) << std::endl
          << *(int *) (s + 1) << std::endl
          << *(int *) (s + 2) << std::endl
          << *(int *) (s + 3) << std::endl;
```

当然在大家的机器里这个通常都是可以运行的，因为 cpu 可能是支持非对齐访存的，只是性能受限。但是 rcore 训练营出来的同学肯定知道 RISCV 非对齐访存是直接会触发硬件异常的。所以在高级语言层面直接转换两个对齐不同的类型的指针肯定是有问题的。

所以我们需要基于联合体的类型双关。虽然我这里写了，这个写法在 C++ 中仍是未定义行为，但是这差不多只是一个设定问题，而不是特别本质的问题，因为这种写法在 C 语言中是良定义的，而且是被鼓励的。假设我们站在 C 语言的视角看这个问题，应该可以发现联合体类型双关至少解决了直接转换指针面临的长度和对齐不匹配的问题。因为当我们定义一个联合体：

```c++
union TypePun {
    char c[7];
    float f;
    int i;
    double d;
};
```

显然，编译器会保证这个联合体类型的变量被定义出来时，它的每个成员都是可以安全访问的，因此联合体整体一定具有这些成员中要求最高的对齐。而当程序员设置其中一个成员而访问另一个成员时，即使访问的成员比设置的成员更大，至少仍然位于整个联合体的范围内，不至于溢出到其他对象、甚至是未分配的空间。因此，这样的访问至少从原理上看是安全的，可以正确反映开发者的意图。

那么，在 C++ 中良定义的类型双关如何实现呢？这个文档也有介绍。第一个方法是 `std::bit_cast`，这个方法各方面堪称和谐，唯一的缺点是需要 C++20。第二个方法是 `std::memcpy`，这个操作在 C 语言中也是良定义的，所以兼容 C 和 C++ 的库建议写成这样，唯一的缺点是这个操作不能在编译期执行。然而向大家通报一个不幸的消息，联合体和直接转换指针的类型双关同样无法用于编译期，因为 C++ 规范要求编译期执行的所有操作都良定义。举个例子：

```c++
constexpr float type_pun(int i) {
    union U {
        int i;
        float f;
    } u{i};
    return u.f;
}

int main(int argc, char **argv) {
    constexpr float f = type_pun(0);
    std::cout << f << std::endl;
    return 0;
}
```

所以在 C++20 之前，没有任何办法能做到在编译期取出浮点数的编码。

## 08_trivial_type

这题就是操作简单结构体，没什么需要讲的。可以读一下阅读材料了解这些名称，不怎么影响开发。

这里的方法的形式就是很典型的 C 语言使用结构体的用法。C 语言没有类，没法定义方法，就只能这样写。

## 09_method

第九题就是把上一题的函数挪到解构里面定义成方法，和上一题没区别，过。

## 10_method_const

第十题是带有 const 修饰的方法。名字和参数都相同，但是 const 修饰符不同的方法是重载关系的两个方法，可以根据调用者是否 const 来决议。举个例子：

```c++
struct A {
    void f() {
        std::cout << "mutable" << std::endl;
    }
    void f() const {
        std::cout << "const" << std::endl;
    }
} a;
a.f();
auto const &a_ = a;
a_.f();
```

## 11_class

十一题主要介绍访问修饰符。注意一下 C++ 里类和结构体的唯一区别是结构体默认 public，类默认 private。

注意一下下面的说明，之前的类型，包括基本类型、数组和简单解构体，声明之后不写直接读是未定义行为。但是类型有无参构造器之后，声明时会直接调用无参构造器来初始化，所以声明直接用不是未定义行为了。但是无参构造器里面可能没有设置所有的成员，对这些成员不写直接读依然是未定义行为。

## 12_class_destruct

十二题是析构的问题，记住凡是调用 new 构造出来的，除非所有权被转让给了特别说明会释放对象的结构体，比如智能指针，否则一定需要调用 delete 才会释放。如果发现你的 new 和 delete 不成对，多半发生了内存泄露。所以 C++ 里安全使用内存是特别难的事，几乎只有在构造器中 new，在析构器中 delete 才能保证正确，所以写大型的 C++ 程序最好保证不在构造器里就不要 new 任何东西。
